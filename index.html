<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3-Omega Data Analyzer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body { font-family: system-ui, sans-serif; margin: 0; background-color: #f0f0f0; color: #333; display: flex; height: 100vh; overflow: hidden; }
        #app-container {
            display: flex;
            flex-direction: column;
            background-color: #ffffff;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            overflow: hidden;
            width: 98%;
            max-width: 1800px;
            height: 100vh;
            margin: 0 auto;
        }
        #main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }
        #controls-panel {
            width: 350px;
            min-width: 200px;
            max-width: 600px;
            flex-shrink: 0;
            padding: 20px;
            background-color: #f9f9f9;
            border-right: 1px solid #e0e0e0;
            overflow-y: auto;
        }
        #drag-handle { width: 6px; cursor: col-resize; background-color: #e0e0e0; flex-shrink: 0; transition: background-color 0.2s; }
        #drag-handle:hover { background-color: #007bff; }
        #controls-panel h1 { font-size: 1.5em; margin-top: 0; margin-bottom: 20px; color: #004494; }
        #controls-panel h2 { font-size: 1.2em; margin-top: 25px; margin-bottom: 15px; color: #004494; border-bottom: 2px solid #e0e0e0; padding-bottom: 5px;}
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; margin-bottom: 8px; font-weight: 600; font-size: 0.9em; }
        .control-group input[type="number"], .control-group select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            color: #111827;
            background-color: white;
        }
        .control-row { display: flex; align-items: center; gap: 10px; }
        .control-row input[type="range"] { flex-grow: 1; }
        .control-row input[type="number"] { width: 100px; }

        .control-row-with-error {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .control-row-with-error input:first-child {
            flex-grow: 1;
        }
        .control-row-with-error input:last-of-type {
            width: 80px;
        }
        .control-row-with-error span {
            font-size: 0.9em;
            color: #555;
        }

        .file-upload-container {
            position: relative;
            display: flex;
            align-items: center;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            padding: 5px;
            overflow: hidden;
        }
        .file-input-hidden {
            display: none;
        }
        .file-input-label {
            background-color: #e0e0e0;
            color: #333;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
            transition: background-color 0.2s;
        }
        .file-input-label:hover {
            background-color: #d0d0d0;
        }
        .file-name-display {
            padding-left: 10px;
            font-size: 0.8em;
            color: #555;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }


        #visualization-area { flex-grow: 1; position: relative; background-color: #ffffff; min-width: 0; display: flex; flex-direction: column; padding: 1.5rem; }
        #plot-container { flex-grow: 1; width: 100%; height: 100%; }
        #plot-container svg { width: 100%; height: 100%; }

        .results-card {
            background-color: #e9f5ff;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.9em;
            border-radius: 4px;
        }
        .results-card h3 { margin-top: 0; color: #004494; }
        .results-card p { margin: 5px 0; }

        #dataset-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #dataset-selector {
            flex-grow: 1;
        }
        #delete-dataset-btn {
            padding: 8px;
            background-color: #ef4444;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            flex-shrink: 0;
        }
        #delete-dataset-btn:hover {
            background-color: #dc2626;
        }
        #save-report-btn {
            width: 100%;
            padding: 10px;
            margin-top: 20px;
            background-color: #16a34a;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }
        #save-report-btn:hover {
            background-color: #15803d;
        }
        #save-report-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }


        footer {
            padding: 8px 20px;
            background-color: #f9f9f9;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: #666;
            flex-shrink: 0;
        }

        /* D3 Plot Styles */
        .axis path, .axis .tick line { stroke: #888; }
        .axis .tick text { fill: #555; font-size: 14px; }
        .line { fill: none; }
        .dot { stroke-width: 1.5px; }
        .axis-label { font-size: 16px; fill: #333; font-weight: 500; }
        .legend { font-size: 14px; }
        .fit-line-in-phase { stroke: #1E40AF; stroke-dasharray: 5, 5; stroke-width: 2px; }
        .fit-line-out-of-phase { stroke: #B45309; stroke-dasharray: 5, 5; stroke-width: 2px; }
        .fit-marker { stroke: red; stroke-width: 1.5px; stroke-dasharray: 4, 4; }
        .axis-label.y-label-left { fill: #1E40AF; }
        .axis-label.y-label-right { fill: #B45309; }
        .axis.y-axis-left .tick text { fill: #1E40AF; }
        .axis.y-axis-left path.domain { stroke: #1E40AF; }
        .axis.y-axis-right .tick text { fill: #B45309; }
        .axis.y-axis-right path.domain { stroke: #B45309; }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="main-content">
            <div id="controls-panel">
                <h1>3-Omega Data Analyzer</h1>

               <div class="control-group">
                    <label>Upload Data File</label>
                    <div class="file-upload-container">
                        <input type="file" id="file-upload" class="file-input-hidden">
                        <label for="file-upload" class="file-input-label">
                            <span>Select file</span>
                        </label>
                        <span id="file-name-display" class="file-name-display">No datafile</span>
                    </div>
                </div>


                <h2>Experimental Parameters</h2>
                <div class="control-group">
                    <label for="wire-length">Voltage Probe Distance (L) [mm]</label>
                    <div class="control-row-with-error">
                        <input type="number" id="wire-length" value="4">
                        <input type="number" id="esd-wire-length-ppm" value="5000" title="Uncertainty in ppm">
                        <span>ppm</span>
                    </div>
                </div>
                <div class="control-group">
                    <label for="wire-width">Wire Width (2b) [mm]</label>
                    <div class="control-row-with-error">
                        <input type="number" id="wire-width" value="0.1">
                        <input type="number" id="esd-wire-width-ppm" value="5000" title="Uncertainty in ppm">
                        <span>ppm</span>
                    </div>
                </div>
                <div class="control-group">
                    <label for="tcr">TCR (α) [1/K]</label>
                    <div class="control-row-with-error">
                        <input type="number" id="tcr" value="0.0035">
                        <input type="number" id="esd-tcr-ppm" value="5000" title="Uncertainty in ppm">
                        <span>ppm</span>
                    </div>
                </div>
                 <div class="control-group">
                    <label for="thickness-substrate">Substrate Thickness (dₛ) [mm]</label>
                    <input type="number" id="thickness-substrate" value="3">
                </div>

                <div id="fitting-controls" class="hidden">
                    <h2>Fitting Controls</h2>
                    <div class="control-group">
                        <label for="fit-method">Fit Method</label>
                        <select id="fit-method">
                            <option value="robust" selected>Robust (Bisquare)</option>
                            <option value="wls">Weighted Least Squares</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="fit-fmin">Min Frequency (Hz)</label>
                        <div class="control-row">
                            <input type="range" id="fit-fmin-slider">
                            <input type="number" id="fit-fmin">
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="fit-fmax">Max Frequency (Hz)</label>
                        <div class="control-row">
                            <input type="range" id="fit-fmax-slider">
                            <input type="number" id="fit-fmax">
                        </div>
                    </div>
                </div>

                <div id="results-container"></div>
                <button id="save-report-btn" class="hidden">Save Report</button>
            </div>
            <div id="drag-handle"></div>
            <div id="visualization-area">
                <div id="plot-container"></div>
            </div>
        </div>
        <footer>
            <span>3-Omega_Analyzer v3.1</span>
            <span>NitaD, Univ Paris-Saclay</span>
        </footer>
    </div>

    <script>
        const { jsPDF } = window.jspdf;
        let parsedFileContent = { datasets: [], jsonHeader: null };
        let analysisResults = [];
        let currentPlotData = {};
        let selectedDatasetIndex = 0;

        document.getElementById('file-upload').addEventListener('change', handleFileSelect, false);
        ['wire-length', 'esd-wire-length-ppm', 'wire-width', 'esd-wire-width-ppm', 'tcr', 'esd-tcr-ppm', 'thickness-substrate', 'fit-method'].forEach(id => {
            document.getElementById(id)?.addEventListener('change', () => {
                 if (parsedFileContent.datasets.length > 0) {
                    analyzeAndDisplay();
                }
            });
        });
        document.getElementById('save-report-btn').addEventListener('click', exportPDFReport);


        function handleFileSelect(event) {
            const file = event.target.files[0];
            const fileNameDisplay = document.getElementById('file-name-display');

            if (!file) {
                fileNameDisplay.textContent = 'Aucun fichier sélectionné';
                return;
            }

            fileNameDisplay.textContent = file.name;

            const reader = new FileReader();
            reader.onload = function(e) {
                const contents = e.target.result;
                parsedFileContent = parseData(contents);
                if (parsedFileContent.datasets.length > 0) {
                    // Calculate TCR from the entire file's data
                    let tcr_result = { value: "unknown", esd: "" };
                    const tcr_data = parsedFileContent.datasets
                        .map(ds => ({ x: ds.avg_temp, y: ds.R0, sigma: ds.esd_R0 }))
                        .filter(d => !isNaN(d.x) && !isNaN(d.y) && d.x > 0);

                    const uniqueTemps = new Set(tcr_data.map(d => d.x));
                    if (tcr_data.length >= 2 && uniqueTemps.size >= 2) {
                        const fit = weightedLinearRegression(tcr_data, 'x', 'y', 'sigma');
                        if (fit.slope !== 0) {
                            const avg_R = d3.mean(tcr_data, d => d.y);
                            const tcr_val = (1 / avg_R) * fit.slope;
                            
                            const rel_err_slope_sq = Math.pow(fit.esd_slope / fit.slope, 2);
                            const std_dev_R = d3.deviation(tcr_data, d => d.y) || 0;
                            const rel_err_R_sq = Math.pow(std_dev_R / avg_R, 2);
                            const tcr_esd = Math.abs(tcr_val) * Math.sqrt(rel_err_slope_sq + rel_err_R_sq);
                            
                            tcr_result = { value: tcr_val, esd: tcr_esd };
                        }
                    }
                    parsedFileContent.calculated_tcr = tcr_result;
                    
                    selectedDatasetIndex = 0;
                    analysisResults = [];
                    document.getElementById('fitting-controls').classList.remove('hidden');
                    document.getElementById('save-report-btn').classList.remove('hidden');
                    setupFittingSliders();
                    analyzeAndDisplay();
                } else {
                    alert("Could not parse any valid datasets from the file.");
                    document.getElementById('fitting-controls').classList.add('hidden');
                    document.getElementById('save-report-btn').classList.add('hidden');
                    document.getElementById('results-container').innerHTML = '';
                    clearPlot();
                }
            };
            reader.readAsText(file);
            event.target.value = null;
        }

        function setupFittingSliders() {
            const allFreqs = parsedFileContent.datasets.flatMap(ds => ds.data.map(d => d.freq));
            const minFreq = Math.max(0.01, Math.min(...allFreqs)); // Prevent log(0)
            const maxFreq = Math.max(...allFreqs);

            const logMin = Math.log(minFreq);
            const logMax = Math.log(maxFreq);

            const fminSlider = document.getElementById('fit-fmin-slider');
            const fminValue = document.getElementById('fit-fmin');
            const fmaxSlider = document.getElementById('fit-fmax-slider');
            const fmaxValue = document.getElementById('fit-fmax');

            fminValue.min = minFreq.toFixed(2);
            fminValue.max = maxFreq.toFixed(2);
            fmaxValue.min = minFreq.toFixed(2);
            fmaxValue.max = maxFreq.toFixed(2);

            fminSlider.min = logMin;
            fminSlider.max = logMax;
            fmaxSlider.min = logMin;
            fmaxSlider.max = logMax;
            
            const step = (logMax - logMin) / 200;
            fminSlider.step = step;
            fmaxSlider.step = step;

            fminSlider.value = logMin;
            fminValue.value = minFreq.toFixed(2);
            fmaxSlider.value = logMax;
            fmaxValue.value = maxFreq.toFixed(2);

            const updateAnalysis = () => {
                if (parsedFileContent.datasets.length > 0) {
                    analyzeAndDisplay();
                }
            };

            fminSlider.oninput = () => {
                const logVal = parseFloat(fminSlider.value);
                fminValue.value = Math.exp(logVal).toFixed(2);
                if (parseFloat(fmaxSlider.value) < logVal) {
                    fmaxSlider.value = logVal;
                    fmaxValue.value = Math.exp(logVal).toFixed(2);
                }
                updateAnalysis();
            };
            fmaxSlider.oninput = () => {
                const logVal = parseFloat(fmaxSlider.value);
                fmaxValue.value = Math.exp(logVal).toFixed(2);
                if (logVal < parseFloat(fminSlider.value)) {
                    fminSlider.value = logVal;
                    fminValue.value = Math.exp(logVal).toFixed(2);
                }
                updateAnalysis();
            };
            fminValue.onchange = () => {
                let val = parseFloat(fminValue.value);
                if (val < minFreq) val = minFreq;
                if (val > maxFreq) val = maxFreq;
                fminValue.value = val.toFixed(2);
                fminSlider.value = Math.log(val);
                updateAnalysis();
            };
            fmaxValue.onchange = () => {
                let val = parseFloat(fmaxValue.value);
                if (val < minFreq) val = minFreq;
                if (val > maxFreq) val = maxFreq;
                fmaxValue.value = val.toFixed(2);
                fmaxSlider.value = Math.log(val);
                updateAnalysis();
            };
        }

        function parseData(fileContent) {
            const firstBrace = fileContent.indexOf('{');
            const lastBrace = fileContent.lastIndexOf('}');
            let startTime = null;
            let jsonHeader = null;

            if (firstBrace !== -1 && lastBrace !== -1) {
                try {
                    jsonHeader = JSON.parse(fileContent.substring(firstBrace, lastBrace + 1));
                    if (jsonHeader["start time"]) {
                        startTime = new Date(jsonHeader["start time"]);
                    }
                } catch (e) {
                    console.error("Could not parse JSON header.", e);
                    jsonHeader = null;
                }
            }

            const datasets = [];
            const blocks = fileContent.split('***');

            blocks.forEach(block => {
                if (!block.trim()) return;

                const lines = block.split('\n');
                const data = [];
                let temperatures = [];
                let isDataSection = false;
                let R0 = NaN;
                let esd_R0 = 0;
                let firstTimeSec = NaN;

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('--- > R0 :')) {
                        const r0_strings = trimmedLine.split(':')[1].trim().split(/\s+/);
                        const r0_values = r0_strings.map(parseFloat).filter(v => !isNaN(v));

                        if (r0_values.length > 0) {
                            const sum = r0_values.reduce((a, b) => a + b, 0);
                            const mean = sum / r0_values.length;
                            R0 = mean;

                            let std_dev = 0;
                            if (r0_values.length > 1) {
                                const sq_diffs = r0_values.map(v => Math.pow(v - mean, 2));
                                const sum_sq_diffs = sq_diffs.reduce((a, b) => a + b, 0);
                                std_dev = Math.sqrt(sum_sq_diffs / (r0_values.length - 1));
                            }
                            const floor_esd = R0 * 100e-6;
                            esd_R0 = Math.max(std_dev, floor_esd);
                        }
                    }
                    if (trimmedLine.startsWith('time /sec')) {
                        isDataSection = true;
                        continue;
                    }
                    if (trimmedLine.startsWith('--- > K and esd K')) {
                        isDataSection = false;
                        continue;
                    }

                    if (isDataSection) {
                        const values = trimmedLine.split(/\s+/);
                        if (values.length >= 11) {
                            if (isNaN(firstTimeSec)) {
                                firstTimeSec = parseFloat(values[0]);
                            }
                            const temp = parseFloat(values[1]);
                            if (!isNaN(temp)) temperatures.push(temp);

                            const freq = parseFloat(values[3]);
                            const v3x = parseFloat(values[6]);
                            const esdV3X = parseFloat(values[7]);
                            const v3y = parseFloat(values[8]);
                            const esdV3Y = parseFloat(values[9]);
                            const isValid = parseFloat(values[10]) === 1;

                            const current_peak_mA = parseFloat(values[2]);
                            const current = (current_peak_mA * 1e-3) / Math.sqrt(2);

                            if (!isNaN(freq) && freq > 0 && !isNaN(v3x) && !isNaN(v3y) && !isNaN(current) && current > 0) {
                                data.push({
                                    freq, v3_in_phase: v3x, v3_out_of_phase: v3y,
                                    esdV3X, esdV3Y, current,
                                    ln_2omega: Math.log(2 * 2 * Math.PI * freq),
                                    isValid
                                });
                            }
                        }
                    }
                }
                if (data.length > 0 && !isNaN(R0)) {
                    let avg_temp = NaN;
                    const validTemps = temperatures.filter(t => t > 0);
                    if (validTemps.length > 0) {
                        avg_temp = validTemps.reduce((a, b) => a + b, 0) / validTemps.length;
                    }

                    let timestamp = new Date();
                    if (startTime && !isNaN(firstTimeSec)) {
                        timestamp = new Date(startTime.getTime() + firstTimeSec * 1000);
                    }
                    datasets.push({ data, R0, esd_R0, timestamp, avg_temp });
                }
            });
            return { datasets, jsonHeader };
        }
        
        function analyzeAndDisplay() {
            if (parsedFileContent.datasets.length === 0) return;

            const L = parseFloat(document.getElementById('wire-length').value) * 1e-3;
            const esd_L_ppm = parseFloat(document.getElementById('esd-wire-length-ppm').value);
            const rel_err_L = esd_L_ppm / 1e6;

            const two_b = parseFloat(document.getElementById('wire-width').value) * 1e-3;
            const esd_two_b_ppm = parseFloat(document.getElementById('esd-wire-width-ppm').value);
            const rel_err_two_b = esd_two_b_ppm / 1e6;
            const b = two_b / 2;

            const alpha_tcr = parseFloat(document.getElementById('tcr').value);
            const esd_tcr_ppm = parseFloat(document.getElementById('esd-tcr-ppm').value);
            const rel_err_tcr = esd_tcr_ppm / 1e6;

            const d_s = parseFloat(document.getElementById('thickness-substrate').value) * 1e-3;
            const fitMethod = document.getElementById('fit-method').value;

            const minFitFreqFromUI = parseFloat(document.getElementById('fit-fmin').value);
            const maxFitFreqFromUI = parseFloat(document.getElementById('fit-fmax').value);
            
            if (isNaN(L) || isNaN(two_b) || isNaN(alpha_tcr) || isNaN(d_s) || isNaN(minFitFreqFromUI) || isNaN(maxFitFreqFromUI)) {
                return;
            }

            const MIN_ESD_V = 5e-9;

            if (analysisResults.length !== parsedFileContent.datasets.length) {
                const allFreqs = parsedFileContent.datasets.flatMap(ds => ds.data.map(d => d.freq));
                const globalMinFreq = Math.max(0.01, Math.min(...allFreqs));
                const globalMaxFreq = Math.max(...allFreqs);

                analysisResults = parsedFileContent.datasets.map(dataset => {
                    const processedData = dataset.data.map(d => {
                        const I_cubed = Math.pow(d.current, 3);
                        const effective_esdV3X = (d.esdV3X > MIN_ESD_V) ? d.esdV3X : MIN_ESD_V;
                        const effective_esdV3Y = (d.esdV3Y > MIN_ESD_V) ? d.esdV3Y : MIN_ESD_V;
                        return {
                            ...d,
                            v3_in_phase_norm: d.v3_in_phase / I_cubed,
                            v3_out_of_phase_norm: d.v3_out_of_phase / I_cubed,
                            esdV3X_norm: effective_esdV3X / I_cubed,
                            esdV3Y_norm: effective_esdV3Y / I_cubed,
                        };
                    });
                    return {
                        ...dataset,
                        allData: processedData,
                        minFitFreq: globalMinFreq,
                        maxFitFreq: globalMaxFreq,
                    };
                });
            }

            if (analysisResults[selectedDatasetIndex]) {
                analysisResults[selectedDatasetIndex].minFitFreq = minFitFreqFromUI;
                analysisResults[selectedDatasetIndex].maxFitFreq = maxFitFreqFromUI;
            }
            
            analysisResults.forEach(result => {
                const { allData, R0, esd_R0, minFitFreq, maxFitFreq } = result;

                const dataForFit = allData.filter(d => d.freq >= minFitFreq && d.freq <= maxFitFreq && d.isValid);

                let inPhaseFit, outOfPhaseFit;
                if (fitMethod === 'robust') {
                    inPhaseFit = robustLinearRegression(dataForFit, 'ln_2omega', 'v3_in_phase_norm', 'esdV3X_norm');
                    outOfPhaseFit = robustLinearRegression(dataForFit, 'ln_2omega', 'v3_out_of_phase_norm', 'esdV3Y_norm');
                } else {
                    inPhaseFit = weightedLinearRegression(dataForFit, 'ln_2omega', 'v3_in_phase_norm', 'esdV3X_norm');
                    outOfPhaseFit = weightedLinearRegression(dataForFit, 'ln_2omega', 'v3_out_of_phase_norm', 'esdV3Y_norm');
                }

                const k = - (Math.pow(R0, 2) * alpha_tcr) / (4 * Math.PI * L * inPhaseFit.slope);
                const relative_err_slope_sq = Math.pow(inPhaseFit.esd_slope / inPhaseFit.slope, 2);
                const relative_err_R0_sq = (R0 > 0 && esd_R0 > 0) ? 4 * Math.pow(esd_R0 / R0, 2) : 0;
                const relative_err_tcr_sq = Math.pow(rel_err_tcr, 2);
                const relative_err_L_sq = Math.pow(rel_err_L, 2);
                const esd_k = Math.abs(k) * Math.sqrt(relative_err_slope_sq + relative_err_R0_sq + relative_err_tcr_sq + relative_err_L_sq);

                let alpha_diffusivity_m2s = NaN;
                let esd_alpha_diffusivity_m2s = NaN;

                const S = inPhaseFit.slope;
                const Ix = inPhaseFit.intercept;
                const Iy = outOfPhaseFit.intercept;
                const esd_S = inPhaseFit.esd_slope;
                const esd_Ix = inPhaseFit.esd_intercept;
                const esd_Iy = outOfPhaseFit.esd_intercept;

                if (S !== 0 && Iy !== 0 && Ix !== 0) {
                    const X = (-Iy - Ix) / S;
                    const fc = (1 / (4 * Math.PI)) * Math.exp(X);
                    alpha_diffusivity_m2s = 2 * Math.PI * fc * b * b;

                    if (esd_S > 0 && esd_Ix > 0 && esd_Iy > 0) {
                        const esd_X_sq = (1 / (S*S)) * (esd_Iy*esd_Iy + esd_Ix*esd_Ix) + Math.pow(X / S, 2) * (esd_S*esd_S);
                        const rel_err_fc_sq = esd_X_sq;
                        const rel_err_b_sq = 4 * Math.pow(rel_err_two_b, 2);

                        esd_alpha_diffusivity_m2s = Math.abs(alpha_diffusivity_m2s) * Math.sqrt(rel_err_fc_sq + rel_err_b_sq);
                    }
                }

                const alpha_diffusivity_mm2s = alpha_diffusivity_m2s * 1e6;
                const esd_alpha_diffusivity_mm2s = esd_alpha_diffusivity_m2s * 1e6;

                result.k = k;
                result.esd_k = esd_k;
                result.alpha = alpha_diffusivity_mm2s;
                result.esd_alpha = esd_alpha_diffusivity_mm2s;
                result.inPhaseFitParams = { slope: inPhaseFit.slope, intercept: inPhaseFit.intercept };
                result.outOfPhaseFitParams = { slope: outOfPhaseFit.slope, intercept: outOfPhaseFit.intercept };
                result.fitData = dataForFit;
            });
            
            renderResultsUI();
            updatePlotForCurrentSelection();
        }

        function weightedLinearRegression(data, xKey, yKey, sigmaKey) {
            const pointsToFit = data.filter(d => d[sigmaKey] > 0);
            const n = pointsToFit.length;
            if (n < 2) return { slope: 0, intercept: 0, esd_slope: 0, esd_intercept: 0, dataForFit: [] };

            let sum_w = 0, sum_wx = 0, sum_wy = 0, sum_wxy = 0, sum_wxx = 0;

            for (const d of pointsToFit) {
                const x = d[xKey];
                const y = d[yKey];
                const sigma = d[sigmaKey];
                const w = 1 / (sigma * sigma);
                sum_w += w;
                sum_wx += w * x;
                sum_wy += w * y;
                sum_wxy += w * x * y;
                sum_wxx += w * x * x;
            }

            const delta = sum_w * sum_wxx - sum_wx * sum_wx;
            if (delta === 0) return { slope: 0, intercept: 0, esd_slope: 0, esd_intercept: 0, dataForFit: pointsToFit };

            const slope = (sum_w * sum_wxy - sum_wx * sum_wy) / delta;
            const intercept = (sum_wxx * sum_wy - sum_wx * sum_wxy) / delta;
            const esd_slope = Math.sqrt(sum_w / delta);
            const esd_intercept = Math.sqrt(sum_wxx / delta);

            return { slope, intercept, esd_slope, esd_intercept, dataForFit: pointsToFit };
        }

        function robustLinearRegression(data, xKey, yKey, sigmaKey) {
            let pointsToFit = data.filter(d => d[sigmaKey] > 0);
            if (pointsToFit.length < 2) return { slope: 0, intercept: 0, esd_slope: 0, esd_intercept: 0, dataForFit: [] };

            let slope, intercept;
            const MAX_ITERATIONS = 25;
            const TOLERANCE = 1e-6;

            let fit = weightedLinearRegression(pointsToFit, xKey, yKey, sigmaKey);
            slope = fit.slope;
            intercept = fit.intercept;

            for (let iter = 0; iter < MAX_ITERATIONS; iter++) {
                const residuals = pointsToFit.map(d => d[yKey] - (slope * d[xKey] + intercept));
                const mad = d3.median(residuals.map(r => Math.abs(r - d3.median(residuals))));

                if (mad === 0) break;

                const c = 4.685;
                const S = mad;

                pointsToFit.forEach((d, i) => {
                    const u = Math.abs(residuals[i] / (c * S));
                    const tukeyWeight = (u < 1) ? Math.pow(1 - u * u, 2) : 0;
                    d.robustWeight = tukeyWeight / Math.pow(d[sigmaKey], 2);
                });

                let sum_w = 0, sum_wx = 0, sum_wy = 0, sum_wxy = 0, sum_wxx = 0;
                pointsToFit.forEach(d => {
                    const w = d.robustWeight;
                    const x = d[xKey];
                    const y = d[yKey];
                    sum_w += w;
                    sum_wx += w * x;
                    sum_wy += w * y;
                    sum_wxy += w * x * y;
                    sum_wxx += w * x * x;
                });

                const delta = sum_w * sum_wxx - sum_wx * sum_wx;
                if (delta === 0) break;

                const newSlope = (sum_w * sum_wxy - sum_wx * sum_wy) / delta;
                const newIntercept = (sum_wxx * sum_wy - sum_wx * sum_wxy) / delta;

                if (Math.abs(newSlope - slope) < TOLERANCE) {
                    slope = newSlope;
                    intercept = newIntercept;
                    break;
                }
                slope = newSlope;
                intercept = newIntercept;
            }

            let sum_w = 0, sum_wxx = 0, sum_wx = 0;
            pointsToFit.forEach(d => {
                const w = d.robustWeight || 0;
                sum_w += w;
                sum_wxx += w * d[xKey] * d[xKey];
                sum_wx += w * d[xKey];
            });
            const delta = sum_w * sum_wxx - sum_wx * sum_wx;
            const esd_slope = (delta > 0) ? Math.sqrt(sum_w / delta) : 0;
            const esd_intercept = (delta > 0) ? Math.sqrt(sum_wxx / delta) : 0;

            return { slope, intercept, esd_slope, esd_intercept, dataForFit: pointsToFit };
        }

        function formatTimestamp(date) {
            if (!(date instanceof Date) || isNaN(date)) {
                return "Invalid Date";
            }
            const YYYY = date.getFullYear();
            const MM = String(date.getMonth() + 1).padStart(2, '0');
            const DD = String(date.getDate()).padStart(2, '0');
            const hh = String(date.getHours()).padStart(2, '0');
            const mm = String(date.getMinutes()).padStart(2, '0');
            const ss = String(date.getSeconds()).padStart(2, '0');
            return `${YYYY}-${MM}-${DD} ${hh}:${mm}:${ss}`;
        }

        function updateFittingUI() {
            if (!analysisResults[selectedDatasetIndex]) return;

            const { minFitFreq, maxFitFreq } = analysisResults[selectedDatasetIndex];

            const fminSlider = document.getElementById('fit-fmin-slider');
            const fminValue = document.getElementById('fit-fmin');
            const fmaxSlider = document.getElementById('fit-fmax-slider');
            const fmaxValue = document.getElementById('fit-fmax');

            fminValue.value = minFitFreq.toFixed(2);
            fmaxValue.value = maxFitFreq.toFixed(2);
            
            fminSlider.value = Math.log(minFitFreq);
            fmaxSlider.value = Math.log(maxFitFreq);
        }

        function renderResultsUI() {
            const resultsContainer = document.getElementById('results-container');
            resultsContainer.innerHTML = '<h2>Analysis Results</h2>';

            if (analysisResults.length === 0) {
                return;
            }

            const controlsContainer = document.createElement('div');
            controlsContainer.id = 'dataset-controls';
            controlsContainer.className = 'control-group';

            const selector = document.createElement('select');
            selector.id = 'dataset-selector';

            analysisResults.forEach((result, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = formatTimestamp(result.timestamp);
                if (index === selectedDatasetIndex) {
                    option.selected = true;
                }
                selector.appendChild(option);
            });

            selector.addEventListener('change', (e) => {
                selectedDatasetIndex = parseInt(e.target.value);
                updateFittingUI();
                displaySingleResult();
                updatePlotForCurrentSelection();
            });

            const deleteBtn = document.createElement('button');
            deleteBtn.id = 'delete-dataset-btn';
            deleteBtn.innerHTML = '&#x1F5D1;';
            deleteBtn.title = "Delete Selected Dataset";
            deleteBtn.onclick = deleteSelectedDataset;

            controlsContainer.appendChild(selector);
            controlsContainer.appendChild(deleteBtn);
            resultsContainer.appendChild(controlsContainer);

            const cardContainer = document.createElement('div');
            cardContainer.id = 'single-result-card-container';
            resultsContainer.appendChild(cardContainer);

            displaySingleResult();
        }

        function displaySingleResult() {
            const cardContainer = document.getElementById('single-result-card-container');
            if (!cardContainer || analysisResults.length === 0 || !analysisResults[selectedDatasetIndex]) {
                if(cardContainer) cardContainer.innerHTML = '';
                return;
            }
            const result = analysisResults[selectedDatasetIndex];

            let alpha_text = `<strong>${result.alpha.toExponential(3)} mm²/s</strong>`;
            if (!isNaN(result.esd_alpha) && result.esd_alpha > 0) {
                alpha_text = `<strong>${result.alpha.toExponential(3)} ± ${result.esd_alpha.toExponential(1)} mm²/s</strong>`;
            }

            let tcr_line = '';
            if (parsedFileContent.calculated_tcr) {
                const tcr = parsedFileContent.calculated_tcr;
                if (tcr.value !== "unknown" && !isNaN(tcr.value)) {
                    tcr_line = `<p>Calculated TCR: <strong>${tcr.value.toExponential(2)} ± ${tcr.esd.toExponential(1)} 1/K</strong></p>`;
                } else {
                    tcr_line = `<p>Calculated TCR: <strong>unknown</strong></p>`;
                }
            }

            cardContainer.innerHTML = `
                <div class="results-card">
                    <h3>Dataset: ${formatTimestamp(result.timestamp)}</h3>
                    <p>Resistance (R₀): <strong>${result.R0.toFixed(2)} ± ${result.esd_R0.toExponential(1)} Ω</strong></p>
                    ${tcr_line}
                    <p>Thermal Cond. (k): <strong>${result.k.toExponential(3)} ± ${result.esd_k.toExponential(1)} W/mK</strong></p>
                    <p>Thermal Diff. (α): ${alpha_text}</p>
                </div>
            `;
        }

        function deleteSelectedDataset() {
            if (analysisResults.length === 0) return;

            const indexToDelete = selectedDatasetIndex;
            parsedFileContent.datasets.splice(indexToDelete, 1);
            analysisResults.splice(indexToDelete, 1);

            if (analysisResults.length === 0) {
                selectedDatasetIndex = 0;
                document.getElementById('results-container').innerHTML = '';
                document.getElementById('fitting-controls').classList.add('hidden');
                document.getElementById('save-report-btn').classList.add('hidden');
                clearPlot();
                return;
            }

            selectedDatasetIndex = Math.max(0, indexToDelete - 1);
            
            renderResultsUI();
            updateFittingUI();
            updatePlotForCurrentSelection();
        }

        function updatePlotForCurrentSelection() {
            if (!analysisResults[selectedDatasetIndex]) {
                clearPlot();
                return;
            };

            currentPlotData = analysisResults[selectedDatasetIndex];
            drawPlot();
        }

        const margin = { top: 60, right: 100, bottom: 120, left: 80 };
        const plotContainer = d3.select("#plot-container");
        let svg, xScale, yScaleLeft, yScaleRight, xAxisBottom, yAxisLeft, yAxisRight, xAxisTop, xScaleTop;
        let isPlotInitialized = false;

        function clearPlot() {
            plotContainer.select("svg").remove();
            isPlotInitialized = false;
        }

        function initPlot() {
            clearPlot();
            const bounds = plotContainer.node().getBoundingClientRect();
             if (bounds.width <= 0 || bounds.height <= 0) return;
            const height = bounds.height;
            const width = bounds.width;

            svg = plotContainer.append("svg").attr("viewBox", `0 0 ${width} ${height}`);
            const plotArea = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            xScale = d3.scaleLinear();
            xScaleTop = d3.scaleLog();
            yScaleLeft = d3.scaleLinear();
            yScaleRight = d3.scaleLinear();

            xAxisBottom = plotArea.append("g").attr("class", "axis x-axis-bottom");
            xAxisTop = plotArea.append("g").attr("class", "axis x-axis-top");
            yAxisLeft = plotArea.append("g").attr("class", "axis y-axis-left");
            yAxisRight = plotArea.append("g").attr("class", "axis y-axis-right");

            svg.append("text").attr("class", "axis-label").attr("id", "x-label-bottom").attr("text-anchor", "middle");
            svg.append("text").attr("class", "axis-label").attr("id", "x-label-top").attr("text-anchor", "middle");
            svg.append("text").attr("class", "axis-label y-label-left").attr("id", "y-label-left").attr("transform", "rotate(-90)").attr("text-anchor", "middle");
            svg.append("text").attr("class", "axis-label y-label-right").attr("id", "y-label-right").attr("transform", "rotate(90)").attr("text-anchor", "middle");

            plotArea.append("g").attr("class", "plot-dots");
            plotArea.append("line").attr("class", "fit-marker").attr("id", "fmin-marker");
            plotArea.append("line").attr("class", "fit-marker").attr("id", "fmax-marker");
            plotArea.append("path").attr("class", "line fit-line-in-phase");
            plotArea.append("path").attr("class", "line fit-line-out-of-phase");

            const legend = svg.append("g").attr("class", "legend");
            const legendItems = [
                { label: "V3_X/I³ rms", color: "#3B82F6" },
                { label: "V3_Y/I³ rms", color: "#F59E0B" },
                { label: "In-Phase Fit", color: "#1E40AF" },
                { label: "Out-of-Phase Fit", color: "#B45309" },
                { label: "Invalid Data", color: "#cccccc" } 
            ];
            legendItems.forEach((item, i) => {
                const legendItem = legend.append("g").attr("transform", `translate(${i * 140}, 0)`);
                legendItem.append("rect").attr("width", 15).attr("height", 15).style("fill", item.color);
                legendItem.append("text").attr("x", 20).attr("y", 12).text(item.label);
            });
            isPlotInitialized = true;
        }

        function drawPlot() {
            const { allData, fitData, inPhaseFitParams, outOfPhaseFitParams, minFitFreq, maxFitFreq } = currentPlotData;
            
            if (!allData || allData.length === 0) {
                clearPlot();
                return;
            };
            if (!isPlotInitialized) initPlot();
            if (!isPlotInitialized) return;

            const bounds = plotContainer.node().getBoundingClientRect();
            const width = bounds.width;
            const height = bounds.height;
            svg.attr("viewBox", `0 0 ${width} ${height}`);

            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            xScale.domain(d3.extent(allData, d => d.ln_2omega)).range([0, plotWidth]);
            xScaleTop.domain(d3.extent(allData, d => d.freq)).range([0, plotWidth]);
            yScaleLeft.domain(d3.extent(allData, d => d.v3_in_phase_norm)).range([plotHeight, 0]).nice();
            yScaleRight.domain(d3.extent(allData, d => d.v3_out_of_phase_norm)).range([plotHeight, 0]).nice();

            xAxisBottom.attr("transform", `translate(0,${plotHeight})`).call(d3.axisBottom(xScale));
            xAxisTop.call(d3.axisTop(xScaleTop).ticks(5, ".0e"));
            yAxisLeft.call(d3.axisLeft(yScaleLeft).tickFormat(d3.format(".2e")));
            yAxisRight.attr("transform", `translate(${plotWidth}, 0)`).call(d3.axisRight(yScaleRight).tickFormat(d3.format(".2e")));

            svg.select("#x-label-bottom").attr("x", margin.left + plotWidth / 2).attr("y", margin.top + plotHeight + 40).text("ln(2ω)");
            svg.select("#x-label-top").attr("x", margin.left + plotWidth / 2).attr("y", 35).text("Frequency (Hz)");
            svg.select("#y-label-left").attr("y", 15).attr("x", 0 - (margin.top + plotHeight / 2)).text("V3/I³ In-Phase (V/A³)");
            svg.select("#y-label-right").attr("y", -(width - 25)).attr("x", (margin.top + plotHeight / 2)).text("V3/I³ Out-of-Phase (V/A³)");

            const legend = svg.select(".legend");
            const legendWidth = legend.node().getBBox().width;
            legend.attr("transform", `translate(${(plotWidth - legendWidth) / 2 + margin.left}, ${margin.top + plotHeight + 70})`);
            
            const fminMarker = svg.select("#fmin-marker");
            const fmaxMarker = svg.select("#fmax-marker");

            if (fitData && fitData.length > 0) {
                const xMin = (minFitFreq >= xScaleTop.domain()[0]) ? xScale(Math.log(2 * 2 * Math.PI * minFitFreq)) : -1;
                const xMax = (maxFitFreq <= xScaleTop.domain()[1]) ? xScale(Math.log(2 * 2 * Math.PI * maxFitFreq)) : -1;
                
                if (xMin >= 0) {
                    fminMarker.attr("x1", xMin).attr("y1", 0).attr("x2", xMin).attr("y2", plotHeight).style("display", null);
                } else { fminMarker.style("display", "none"); }
                
                if (xMax >= 0) {
                    fmaxMarker.attr("x1", xMax).attr("y1", 0).attr("x2", xMax).attr("y2", plotHeight).style("display", null);
                } else { fmaxMarker.style("display", "none"); }
            } else {
                fminMarker.style("display", "none");
                fmaxMarker.style("display", "none");
            }

            const dotsGroup = svg.select(".plot-dots");
            dotsGroup.selectAll("*").remove();

            dotsGroup.selectAll(".dot-in-phase").data(allData).enter().append("circle")
                .attr("class", "dot dot-in-phase").attr("cx", d => xScale(d.ln_2omega)).attr("cy", d => yScaleLeft(d.v3_in_phase_norm))
                .attr("r", d => d.isValid ? 4 : 2).style("fill", d => d.isValid ? "#3B82F6" : "#cccccc").style("opacity", d => d.isValid ? 1.0 : 0.7);

            dotsGroup.selectAll(".dot-out-of-phase").data(allData).enter().append("circle")
                .attr("class", "dot dot-out-of-phase").attr("cx", d => xScale(d.ln_2omega)).attr("cy", d => yScaleRight(d.v3_out_of_phase_norm))
                .attr("r", d => d.isValid ? 4 : 2).style("fill", d => d.isValid ? "#F59E0B" : "#cccccc").style("opacity", d => d.isValid ? 1.0 : 0.7);

            const fitLineInPhase = svg.select(".fit-line-in-phase");
            const fitLineOutOfPhase = svg.select(".fit-line-out-of-phase");

            if(fitData && fitData.length > 1 && inPhaseFitParams) {
                const lineInPhaseFunc = d3.line().x(d => xScale(d.ln_2omega)).y(d => yScaleLeft(d.ln_2omega * inPhaseFitParams.slope + inPhaseFitParams.intercept));
                fitLineInPhase.datum(fitData).attr("d", lineInPhaseFunc);
            } else {
                fitLineInPhase.attr("d", null);
            }

            if(fitData && fitData.length > 1 && outOfPhaseFitParams) {
                 const lineOutOfPhaseFunc = d3.line().x(d => xScale(d.ln_2omega)).y(d => yScaleRight(d.ln_2omega * outOfPhaseFitParams.slope + outOfPhaseFitParams.intercept));
                fitLineOutOfPhase.datum(fitData).attr("d", lineOutOfPhaseFunc);
            } else {
                fitLineOutOfPhase.attr("d", null);
            }
        }

        function sanitizeForPDF(text) {
            return text.replace(/Ω/g, 'Ohm')
                       .replace(/α/g, 'alpha')
                       .replace(/₀/g, '0')
                       .replace(/ₛ/g, 's')
                       .replace(/±/g, '+/-');
        }

        async function exportPDFReport() {
            const btn = document.getElementById('save-report-btn');
            btn.textContent = 'Generating...';
            btn.disabled = true;

            const originalSelectedDatasetIndex = selectedDatasetIndex;

            try {
                const pdf = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 15;
                let yPos = margin;

                pdf.setFontSize(18);
                pdf.text("3-Omega Analysis", pageWidth / 2, yPos, { align: 'center' });
                yPos += 8;
                pdf.setFontSize(10);
                pdf.text(`Program used github.com/nitad54448/calc_3omega. Report generated on: ${new Date().toLocaleString()}`, pageWidth / 2, yPos, { align: 'center' });
                yPos += 8;
                const footerText = document.querySelector('footer').textContent.trim().replace(/\s+/g, ' | ');
                pdf.text(footerText, pageWidth / 2, yPos, { align: 'center' });
                yPos += 12;

                pdf.setFontSize(12);
                pdf.text("Data File Header Information", margin, yPos);
                yPos += 6;
                pdf.setLineWidth(0.2);
                pdf.line(margin, yPos, pageWidth - margin, yPos);
                yPos += 8;

                pdf.setFontSize(8).setFont('courier');
                if (parsedFileContent.jsonHeader) {
                    const headerString = JSON.stringify(parsedFileContent.jsonHeader, null, 2);
                    const headerLines = pdf.splitTextToSize(headerString, pageWidth - 2 * margin);

                    for (const line of headerLines) {
                        if (yPos > pageHeight - margin) {
                            pdf.addPage();
                            yPos = margin;
                        }
                        pdf.text(line, margin, yPos);
                        yPos += 4;
                    }
                } else {
                    pdf.text("No JSON header found in the data file.", margin, yPos);
                }
                pdf.setFont('helvetica').setFontSize(10);

                for (let i = 0; i < analysisResults.length; i++) {
                    pdf.addPage();
                    yPos = margin;
                    const result = analysisResults[i];

                    pdf.setFontSize(16);
                    pdf.text(`Dataset: ${formatTimestamp(result.timestamp)}`, pageWidth / 2, yPos, { align: 'center' });
                    yPos += 12;

                    pdf.setFontSize(12);
                    pdf.text("Parameters & Results", margin, yPos);
                    yPos += 6;
                    pdf.setLineWidth(0.2);
                    pdf.line(margin, yPos, pageWidth - margin, yPos);
                    yPos += 8;

                    pdf.setFontSize(9);

                    const col1_x = margin;
                    const col2_x = margin + (pageWidth - 2 * margin) / 2;
                    let yPos_col1 = yPos;
                    let yPos_col2 = yPos;

                    const L_val_mm = parseFloat(document.getElementById('wire-length').value);
                    const L_ppm = parseFloat(document.getElementById('esd-wire-length-ppm').value);
                    const L_esd_mm = L_val_mm * (L_ppm / 1e6);

                    const two_b_val_mm = parseFloat(document.getElementById('wire-width').value);
                    const two_b_ppm = parseFloat(document.getElementById('esd-wire-width-ppm').value);
                    const two_b_esd_mm = two_b_val_mm * (two_b_ppm / 1e6);

                    const tcr_val = parseFloat(document.getElementById('tcr').value);
                    const tcr_ppm = parseFloat(document.getElementById('esd-tcr-ppm').value);
                    const tcr_esd = tcr_val * (tcr_ppm / 1e6);

                    pdf.text(sanitizeForPDF(`Voltage Probe Distance (L): ${L_val_mm.toFixed(3)} +/- ${L_esd_mm.toExponential(1)} mm`), col1_x, yPos_col1); yPos_col1 += 6;
                    pdf.text(sanitizeForPDF(`Wire Width (2b): ${two_b_val_mm.toFixed(3)} +/- ${two_b_esd_mm.toExponential(1)} mm`), col1_x, yPos_col1); yPos_col1 += 6;
                    pdf.text(sanitizeForPDF(`TCR (α): ${tcr_val.toExponential(3)} +/- ${tcr_esd.toExponential(1)} 1/K`), col1_x, yPos_col1); yPos_col1 += 6;
                    pdf.text(sanitizeForPDF(`Substrate Thickness (dₛ): ${document.getElementById('thickness-substrate').value} mm`), col1_x, yPos_col1); yPos_col1 += 6;
                    pdf.text(`Fitting Range: ${result.minFitFreq.toFixed(2)} Hz to ${result.maxFitFreq.toFixed(2)} Hz`, col1_x, yPos_col1); yPos_col1 += 6;
                    pdf.text(`Fit Method: ${document.getElementById('fit-method').value}`, col1_x, yPos_col1); yPos_col1 += 6;

                    pdf.text(sanitizeForPDF(`Resistance (R₀): ${result.R0.toFixed(2)} ± ${result.esd_R0.toExponential(1)} Ω`), col2_x, yPos_col2); yPos_col2 += 6;
                    pdf.text(sanitizeForPDF(`Thermal Conductivity (k): ${result.k.toExponential(3)} ± ${result.esd_k.toExponential(1)} W/mK`), col2_x, yPos_col2); yPos_col2 += 6;

                    let alpha_text_pdf = sanitizeForPDF(`${result.alpha.toExponential(3)} mm²/s`);
                    if (!isNaN(result.esd_alpha) && result.esd_alpha > 0) {
                        alpha_text_pdf = sanitizeForPDF(`${result.alpha.toExponential(3)} ± ${result.esd_alpha.toExponential(1)} mm²/s`);
                    }
                    pdf.text(sanitizeForPDF(`Thermal Diffusivity (α): ${alpha_text_pdf}`), col2_x, yPos_col2); yPos_col2 += 6;

                    yPos = Math.max(yPos_col1, yPos_col2) + 5;

                    selectedDatasetIndex = i;
                    document.getElementById('dataset-selector').value = i;
                    updatePlotForCurrentSelection();
                    await new Promise(resolve => setTimeout(resolve, 100));

                    const visArea = document.getElementById('visualization-area');
                    const canvas = await html2canvas(visArea, { scale: 2, backgroundColor: '#ffffff' });
                    const imgData = canvas.toDataURL('image/png');

                    const availableHeight = pageHeight - yPos - margin;
                    let imgWidth = pageWidth - 2 * margin;
                    let imgHeight = (canvas.height * imgWidth) / canvas.width;

                    if (imgHeight > availableHeight) {
                        imgHeight = availableHeight;
                        imgWidth = (canvas.width * imgHeight) / canvas.height;
                    }

                    const imgX = (pageWidth - imgWidth) / 2;
                    pdf.addImage(imgData, 'PNG', imgX, yPos, imgWidth, imgHeight);
                }

                pdf.save(`3omega_report_${new Date().toISOString().replace(/[:.]/g, '-')}.pdf`);

            } catch (error) {
                console.error("Error generating PDF:", error);
                const resultsContainer = document.getElementById('results-container');
                const errorDiv = document.createElement('div');
                errorDiv.style.color = 'red';
                errorDiv.textContent = 'An error occurred while generating the PDF. See the browser console for details.';
                resultsContainer.prepend(errorDiv);

            } finally {
                selectedDatasetIndex = originalSelectedDatasetIndex;
                document.getElementById('dataset-selector').value = selectedDatasetIndex;
                updatePlotForCurrentSelection();
                btn.textContent = 'Save Report';
                btn.disabled = false;
            }
        }


        // --- Resizer Logic ---
        const resizer = document.getElementById('drag-handle');
        const leftPanel = document.getElementById('controls-panel');
        let isResizing = false;
        resizer.addEventListener('mousedown', e => {
            e.preventDefault(); isResizing = true;
            document.body.style.cursor = 'col-resize'; document.body.style.userSelect = 'none';
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', stopResize);
        });
        function handleMouseMove(e) {
            if (!isResizing) return;
            const newLeftWidth = e.clientX - resizer.parentElement.getBoundingClientRect().left;
            if (newLeftWidth > 350 && newLeftWidth < resizer.parentElement.clientWidth - 400) {
                leftPanel.style.width = `${newLeftWidth}px`;
                drawPlot();
            }
        }
        function stopResize() {
            isResizing = false;
            document.body.style.cursor = 'default'; document.body.style.userSelect = 'auto';
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', stopResize);
        }

        window.addEventListener('load', () => {
             new ResizeObserver(() => {
                if (currentPlotData.allData) {
                    initPlot();
                    drawPlot();
                }
             }).observe(plotContainer.node());
        });
    </script>
</body>
</html>