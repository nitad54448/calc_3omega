<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3-Omega 3D Surface Fit Analyzer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body { font-family: system-ui, sans-serif; margin: 0; background-color: #f0f0f0; color: #333; display: flex; height: 100vh; overflow: hidden; }
        #app-container {
            display: flex;
            flex-direction: column;
            background-color: #ffffff;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            overflow: hidden;
            width: 98%;
            max-width: 1800px;
            height: 100vh;
            margin: 0 auto;
        }
        #main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }
        #controls-panel {
            width: 380px;
            min-width: 200px;
            max-width: 600px;
            flex-shrink: 0;
            padding: 20px;
            background-color: #f9f9f9;
            border-right: 1px solid #e0e0e0;
            overflow-y: auto;
        }
        #drag-handle { width: 6px; cursor: col-resize; background-color: #e0e0e0; flex-shrink: 0; transition: background-color 0.2s; }
        #drag-handle:hover { background-color: #007bff; }
        #controls-panel h1 { font-size: 1.5em; margin-top: 0; margin-bottom: 20px; color: #004494; }
        #controls-panel h2 { font-size: 1.2em; margin-top: 25px; margin-bottom: 15px; color: #004494; border-bottom: 2px solid #e0e0e0; padding-bottom: 5px;}
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; margin-bottom: 8px; font-weight: 600; font-size: 0.9em; }
        .control-group input[type="number"], .control-group select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            color: #111827;
            background-color: white;
        }
        .control-row { display: flex; align-items: center; gap: 10px; }
        .control-row input[type="range"] { flex-grow: 1; }
        .control-row input[type="number"] { width: 100px; }

        .control-row-with-error {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .control-row-with-error input:first-child {
            flex-grow: 1;
        }
        .control-row-with-error input:last-of-type {
            width: 80px;
        }
        .control-row-with-error span {
            font-size: 0.9em;
            color: #555;
        }

        .file-upload-container {
            position: relative;
            display: flex;
            align-items: center;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            padding: 5px;
            overflow: hidden;
        }
        .file-input-hidden {
            display: none;
        }
        .file-input-label {
            background-color: #e0e0e0;
            color: #333;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
            transition: background-color 0.2s;
        }
        .file-input-label:hover {
            background-color: #d0d0d0;
        }
        .file-name-display {
            padding-left: 10px;
            font-size: 0.8em;
            color: #555;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }


        #visualization-area { flex-grow: 1; position: relative; background-color: #ffffff; min-width: 0; display: flex; flex-direction: column; padding: 1.5rem; }
        #plot-container { flex-grow: 1; width: 100%; height: 100%; }
        #plot-container .svg-container { width: 100%; height: 100%; } /* D3 plot container */


        .results-card {
            background-color: #e9f5ff;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.9em;
            border-radius: 4px;
        }
        .results-card h3 { margin-top: 0; color: #004494; }
        .results-card p { margin: 5px 0; }

        #dataset-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        #dataset-navigation {
            display: flex;
            flex-direction: column;
        }
        .nav-btn {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            line-height: 1;
        }
        .nav-btn:hover {
            background-color: #e0e0e0;
        }
        #dataset-selector {
            flex-grow: 1;
        }
        #delete-dataset-btn {
            padding: 8px;
            background-color: #ef4444;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            flex-shrink: 0;
        }
        #delete-dataset-btn:hover {
            background-color: #dc2626;
        }
        #save-report-btn {
            width: 100%;
            padding: 10px;
            margin-top: 20px;
            background-color: #16a34a;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }
        #save-report-btn:hover {
            background-color: #15803d;
        }
        #save-report-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }


        footer {
            padding: 8px 20px;
            background-color: #f9f9f9;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: #666;
            flex-shrink: 0;
        }

        /* Plot style */
        .axis path, .axis .tick line { stroke: #888; }
        .axis .tick text { fill: #555; font-size: 14px; }
        .axis-label { font-size: 16px; fill: #333; font-weight: 500; }
        .rt-fit-line { stroke: #d97706; stroke-width: 2.5px; stroke-dasharray: 6, 6; fill: none; }
        .rt-data-point { fill: #059669; }
        .rt-error-bar { stroke: #555; stroke-width: 1px; }

        #pdf-plot-temp-container {
            position: absolute;
            left: -9999px;
            top: -9999px;
            width: 800px;
            height: 1200px;
            background-color: white;
            z-index: -100;
        }
        
        #error-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-group-checkbox {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 18px;
        }
        .control-group-checkbox label {
            margin-bottom: 0;
        }
        
        .label-with-global {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .label-with-global > label {
            margin-bottom: 0; 
        }
        .global-toggle {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .global-toggle label {
            font-weight: normal;
            font-size: 0.85em;
            color: #555;
            cursor: pointer;
        }
        .global-toggle input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="main-content">
            <div id="controls-panel">
                <h1>3-Omega 3D Surface Fit Analyzer</h1>

               <div class="control-group">
                    <label>Upload Data File</label>
                    <div class="file-upload-container">
                        <input type="file" id="file-upload" class="file-input-hidden">
                        <label for="file-upload" class="file-input-label">
                            <span>Select file</span>
                        </label>
                        <span id="file-name-display" class="file-name-display">No datafile</span>
                    </div>
                </div>

                <div class="control-group-checkbox">
                    <label for="phase-shift-180">Apply 180° Phase Correction</label>
                    <input type="checkbox" id="phase-shift-180" style="width: 20px; height: 20px; cursor: pointer;">
                </div>


                <h2>Experimental Parameters</h2>
                <div class="control-group">
                    <label for="wire-length">Voltage Probe Distance (L) [mm]</label>
                    <div class="control-row-with-error">
                        <input type="number" id="wire-length" value="4">
                        <input type="number" id="esd-wire-length-ppm" value="5000" title="Uncertainty in ppm">
                        <span>ppm</span>
                    </div>
                </div>
                <div class="control-group">
                    <label for="wire-width">Wire Width (2b) [mm]</label>
                    <div class="control-row-with-error">
                        <input type="number" id="wire-width" value="0.1">
                        <input type="number" id="esd-wire-width-ppm" value="5000" title="Uncertainty in ppm">
                        <span>ppm</span>
                    </div>
                </div>
                <div class="control-group">
                    <label for="thickness-substrate">Substrate Thickness (dₛ) [mm]</label>
                    <input type="number" id="thickness-substrate" value="3">
                </div>

                <h2>R(T) = C₂T² + C₁T + C₀</h2>
                <div class="control-group">
                    <label for="tcr-c0">C0 (Ohm)</label>
                    <input type="number" id="tcr-c0" value="0" step="any">
                </div>
                <div class="control-group">
                    <label for="tcr-c1">C1 (Ohm/K)</label>
                    <input type="number" id="tcr-c1" value="0.0035" step="any">
                </div>
                <div class="control-group">
                    <label for="tcr-c2">C2 (Ohm/K^2)</label>
                    <input type="number" id="tcr-c2" value="0" step="any">
                </div>

                <div id="fitting-controls" class="hidden">
                    <h2>Fitting Controls (Linear Fit)</h2>
                    <div class="control-group">
                        <label for="fit-method">Fit Method</label>
                        <select id="fit-method">
                            <option value="wls">Weighted Least Squares</option>
                            <option value="robust" selected>Robust (Bisquare)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <div class="label-with-global">
                            <label for="fit-fmin">Min Frequency (Hz)</label>
                            <div class="global-toggle">
                                <input type="checkbox" id="fit-fmin-global">
                                <label for="fit-fmin-global">Global</label>
                            </div>
                        </div>
                        <div class="control-row">
                            <input type="range" id="fit-fmin-slider">
                            <input type="number" id="fit-fmin">
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="label-with-global">
                            <label for="fit-fmax">Max Frequency (Hz)</label>
                             <div class="global-toggle">
                                <input type="checkbox" id="fit-fmax-global">
                                <label for="fit-fmax-global">Global</label>
                            </div>
                        </div>
                        <div class="control-row">
                            <input type="range" id="fit-fmax-slider">
                            <input type="number" id="fit-fmax">
                        </div>
                    </div>
                    <div id="recommended-fit-range-container"></div>
                </div>

                <div id="results-container"></div>
                <button id="save-report-btn" class="hidden">Save Report</button>
            </div>
            <div id="drag-handle"></div>
            <div id="visualization-area">
                <div id="plot-container"></div>
            </div>
        </div>
        <footer>
            <span>3Omega_3DFit v3.9, 13 August 2025</span>
            <span>NitaD, Univ Paris-Saclay</span>
        </footer>
    </div>
    <div id="pdf-plot-temp-container"></div>
    <div id="error-container"></div>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        const { jsPDF } = window.jspdf;
        let parsedFileContent = { datasets: [], jsonHeader: null };
        let analysisResults = [];
        let selectedDatasetIndex = 0;
        let isShowingRTPlot = false;

        document.getElementById('file-upload').addEventListener('change', handleFileSelect, false);
        
        const globalParamIds = ['wire-length', 'esd-wire-length-ppm', 'wire-width', 'esd-wire-width-ppm', 'thickness-substrate', 'phase-shift-180'];
        globalParamIds.forEach(id => {
            document.getElementById(id)?.addEventListener('change', () => {
                 if (parsedFileContent.datasets.length > 0) analyzeAndDisplay(true);
            });
        });
        
        const tcrCoeffIds = ['tcr-c0', 'tcr-c1', 'tcr-c2'];
        tcrCoeffIds.forEach(id => {
            document.getElementById(id)?.addEventListener('change', () => {
                if (parsedFileContent.datasets.length > 0) {
                    analyzeAndDisplay(true);
                    isShowingRTPlot = true;
                    updateVisualization();
                }
            });
        });

        const localParamIds = ['fit-method'];
        localParamIds.forEach(id => {
            document.getElementById(id)?.addEventListener('change', () => {
                 if (parsedFileContent.datasets.length > 0) analyzeAndDisplay(false);
            });
        });
        document.getElementById('save-report-btn').addEventListener('click', exportPDFReport);

        function showError(message, duration = 5000) {
            const errorContainer = document.getElementById('error-container');
            const errorDiv = document.createElement('div');
            errorDiv.textContent = message;
            errorDiv.style.backgroundColor = '#ef4444';
            errorDiv.style.color = 'white';
            errorDiv.style.padding = '10px 20px';
            errorDiv.style.borderRadius = '5px';
            errorDiv.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
            errorDiv.style.opacity = '1';
            errorDiv.style.transition = 'opacity 0.5s ease-out';
            errorContainer.appendChild(errorDiv);
            setTimeout(() => {
                errorDiv.style.opacity = '0';
                setTimeout(() => errorDiv.remove(), 500);
            }, duration);
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            const fileNameDisplay = document.getElementById('file-name-display');

            if (!file) {
                fileNameDisplay.textContent = 'No file selected';
                return;
            }
            fileNameDisplay.textContent = file.name;
            document.body.style.cursor = 'wait';

            const reader = new FileReader();
            reader.onload = function(e) {
                setTimeout(() => {
                    const contents = e.target.result;
                    parsedFileContent = parseData(contents);
                    if (parsedFileContent.datasets.length > 0) {
                        
                        const tcr_data = parsedFileContent.datasets
                            .map(ds => ({ x: ds.avg_temp, y: ds.R0, sigma: ds.esd_R0 }))
                            .filter(d => !isNaN(d.x) && !isNaN(d.y) && d.x > 0);

                        const uniqueTemps = new Set(tcr_data.map(d => d.x));
                        if (tcr_data.length >= 2 && uniqueTemps.size >= 2) {
                            const fit_coeffs = weightedPolynomialRegression2ndOrder(tcr_data);
                            if (fit_coeffs.success) {
                                parsedFileContent.rt_fit_coefficients = fit_coeffs;
                                document.getElementById('tcr-c0').value = fit_coeffs.c0.toExponential(4);
                                document.getElementById('tcr-c1').value = fit_coeffs.c1.toExponential(4);
                                document.getElementById('tcr-c2').value = fit_coeffs.c2.toExponential(4);
                            }
                        }
                        
                        const allFreqs = parsedFileContent.datasets.flatMap(ds => ds.data.map(d => d.freq));
                        const globalMinFreq = Math.max(0.01, Math.min(...allFreqs));
                        const globalMaxFreq = Math.max(...allFreqs);
                        
                        analysisResults = parsedFileContent.datasets.map(dataset => {
                            return { ...dataset, minFitFreq: globalMinFreq, maxFitFreq: globalMaxFreq };
                        });

                        selectedDatasetIndex = 0;
                        isShowingRTPlot = false;
                        document.getElementById('fitting-controls').classList.remove('hidden');
                        document.getElementById('save-report-btn').classList.remove('hidden');
                        setupFittingSliders();
                        analyzeAndDisplay(true); // This will reset the cursor
                    } else {
                        showError("Could not parse any valid datasets from the file.");
                        document.getElementById('fitting-controls').classList.add('hidden');
                        document.getElementById('save-report-btn').classList.add('hidden');
                        document.getElementById('results-container').innerHTML = '';
                        clearPlot();
                        document.body.style.cursor = 'default';
                    }
                }, 10);
            };
            reader.readAsText(file);
            event.target.value = null;
        }

    function setupFittingSliders() {
            const allFreqs = parsedFileContent.datasets.flatMap(ds => ds.data.map(d => d.freq));
            const minFreq = Math.max(0.01, Math.min(...allFreqs));
            const maxFreq = Math.max(...allFreqs);

            const logMin = Math.log(minFreq);
            const logMax = Math.log(maxFreq);

            const fminSlider = document.getElementById('fit-fmin-slider');
            const fminValue = document.getElementById('fit-fmin');
            const fminGlobal = document.getElementById('fit-fmin-global');
            const fmaxSlider = document.getElementById('fit-fmax-slider');
            const fmaxValue = document.getElementById('fit-fmax');
            const fmaxGlobal = document.getElementById('fit-fmax-global');

            fminValue.min = minFreq.toFixed(2); fminValue.max = maxFreq.toFixed(2);
            fmaxValue.min = minFreq.toFixed(2); fmaxValue.max = maxFreq.toFixed(2);
            fminSlider.min = logMin; fminSlider.max = logMax;
            fmaxSlider.min = logMin; fmaxSlider.max = logMax;

            const step = (logMax - logMin) / 200;
            fminSlider.step = step; fmaxSlider.step = step;
            fminSlider.value = logMin; fminValue.value = minFreq.toFixed(2);
            fmaxSlider.value = logMax; fmaxValue.value = maxFreq.toFixed(2);

            const updateAnalysisAfterFreqChange = () => {
                if (parsedFileContent.datasets.length === 0) return;
                isShowingRTPlot = false;
                const minFreqVal = parseFloat(fminValue.value);
                const maxFreqVal = parseFloat(fmaxValue.value);
                let analyzeAll = false;

                if (fminGlobal.checked) {
                    analysisResults.forEach(res => res.minFitFreq = minFreqVal);
                    analyzeAll = true;
                }
                if (fmaxGlobal.checked) {
                    analysisResults.forEach(res => res.maxFitFreq = maxFreqVal);
                    analyzeAll = true;
                }
                
                const currentResult = analysisResults[selectedDatasetIndex];
                if (currentResult) {
                    if (!fminGlobal.checked) currentResult.minFitFreq = minFreqVal;
                    if (!fmaxGlobal.checked) currentResult.maxFitFreq = maxFreqVal;
                }
                analyzeAndDisplay(analyzeAll);
            };

            fminSlider.oninput = () => {
                const logVal = parseFloat(fminSlider.value);
                fminValue.value = Math.exp(logVal).toFixed(2);
                if (parseFloat(fmaxSlider.value) < logVal) {
                    fmaxSlider.value = logVal;
                    fmaxValue.value = Math.exp(logVal).toFixed(2);
                }
                updateAnalysisAfterFreqChange();
            };
            fmaxSlider.oninput = () => {
                const logVal = parseFloat(fmaxSlider.value);
                fmaxValue.value = Math.exp(logVal).toFixed(2);
                if (logVal < parseFloat(fminSlider.value)) {
                    fminSlider.value = logVal;
                    fminValue.value = Math.exp(logVal).toFixed(2);
                }
                updateAnalysisAfterFreqChange();
            };
            fminValue.onchange = () => {
                let val = parseFloat(fminValue.value);
                if (isNaN(val) || val <= 0) val = 0.01;
                if (val > maxFreq) val = maxFreq;
                fminValue.value = val.toFixed(2);
                fminSlider.value = Math.log(val);
                updateAnalysisAfterFreqChange();
            };
            fmaxValue.onchange = () => {
                let val = parseFloat(fmaxValue.value);
                if (isNaN(val) || val < minFreq) val = minFreq;
                if (val > maxFreq) val = maxFreq;
                fmaxValue.value = val.toFixed(2);
                fmaxSlider.value = Math.log(val);
                updateAnalysisAfterFreqChange();
            };
            
            fminGlobal.onchange = updateAnalysisAfterFreqChange;
            fmaxGlobal.onchange = updateAnalysisAfterFreqChange;
        }

        function parseData(fileContent) {
            const firstBrace = fileContent.indexOf('{');
            const lastBrace = fileContent.lastIndexOf('}');
            let startTime = null;
            let jsonHeader = null;

            if (firstBrace !== -1 && lastBrace !== -1) {
                try {
                    jsonHeader = JSON.parse(fileContent.substring(firstBrace, lastBrace + 1));
                    if (jsonHeader["start time"]) startTime = new Date(jsonHeader["start time"]);
                } catch (e) {
                    console.error("Could not parse JSON header.", e);
                    jsonHeader = null;
                }
            }

            const datasets = [];
            const blocks = fileContent.split('***');
            blocks.forEach(block => {
                if (!block.trim()) return;
                const lines = block.split('\n');
                const data = [];
                let temperatures = [];
                let isDataSection = false;
                let R0 = NaN, esd_R0 = 0, firstTimeSec = NaN;

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('--- > R0 :')) {
                        const r0_strings = trimmedLine.split(':')[1].trim().split(/\s+/);
                        const r0_values = r0_strings.map(parseFloat).filter(v => !isNaN(v));
                        if (r0_values.length > 0) {
                            R0 = d3.mean(r0_values);
                            const std_dev = d3.deviation(r0_values) || 0;
                            esd_R0 = Math.max(std_dev, R0 * 100e-6);
                        }
                    }
                    if (trimmedLine.startsWith('time /sec')) { isDataSection = true; continue; }
                    if (trimmedLine.startsWith('--- > K and esd K')) { isDataSection = false; continue; }

                    if (isDataSection) {
                        const values = trimmedLine.split(/\s+/);
                        if (values.length >= 11) {
                            if (isNaN(firstTimeSec)) firstTimeSec = parseFloat(values[0]);
                            const temp = parseFloat(values[1]);
                            if (!isNaN(temp)) temperatures.push(temp);

                            const freq = parseFloat(values[3]);
                            const v3x = parseFloat(values[6]);
                            const esdV3X = parseFloat(values[7]);
                            const v3y = parseFloat(values[8]);
                            const esdV3Y = parseFloat(values[9]);
                            const isValid = parseFloat(values[10]) === 1;
                            const current_peak_mA = parseFloat(values[2]);
                            const current = (current_peak_mA * 1e-3) / Math.sqrt(2); // RMS current

                            if (!isNaN(freq) && freq > 0 && !isNaN(v3x) && !isNaN(v3y) && !isNaN(current) && current > 0) {
                                data.push({
                                    freq, v3_in_phase: v3x, v3_out_of_phase: v3y,
                                    esdV3X, esdV3Y, current,
                                    ln_2omega: Math.log(2 * 2 * Math.PI * freq),
                                    i_cubed: Math.pow(current, 3),
                                    isValid
                                });
                            }
                        }
                    }
                }
                if (data.length > 0 && !isNaN(R0)) {
                    let avg_temp = d3.mean(temperatures.filter(t => t > 0)) || NaN;
                    let timestamp = (startTime && !isNaN(firstTimeSec)) ? new Date(startTime.getTime() + firstTimeSec * 1000) : new Date();
                    datasets.push({ data, R0, esd_R0, timestamp, avg_temp });
                }
            });
            return { datasets, jsonHeader };
        }
        
        /**
         * Solves V = q2*X2 - q1*X1 where X1=I^3*ln(2w) and X2=I^3
         * using weighted multiple linear regression. This is non-iterative and robust.
         * It uses column scaling to improve numerical stability.
         */
        function performScaledMLR(dataPoints, isRobust = false) {
            
            let points = dataPoints.map(p => ({
                y: p.v3,
                x1_raw: -p.i_cubed * p.ln_2omega,
                x2_raw: p.i_cubed,
                weight: p.weight
            }));

            // Calculate scaling factors (RMS of each column)
            const n = points.length;
            const s1 = Math.sqrt(points.reduce((sum, p) => sum + p.x1_raw * p.x1_raw, 0) / n);
            const s2 = Math.sqrt(points.reduce((sum, p) => sum + p.x2_raw * p.x2_raw, 0) / n);
            
            if (s1 === 0 || s2 === 0) return { success: false, reason: "Data variation is zero." };
            
            // Apply scaling
            points.forEach(p => {
                p.x1 = p.x1_raw / s1;
                p.x2 = p.x2_raw / s2;
                p.robustWeight = p.weight;
            });

            let q_scaled = [0, 0], esd_q_scaled = [NaN, NaN];

            for (let robust_iter = 0; robust_iter < (isRobust ? 10 : 1); robust_iter++) {
                let XTWX = [[0, 0], [0, 0]]; // X'WX
                let XTWY = [0, 0];       // X'WY

                for (const p of points) {
                    if (p.robustWeight === 0) continue;
                    const w = p.robustWeight;
                    XTWX[0][0] += p.x1 * p.x1 * w;
                    XTWX[0][1] += p.x1 * p.x2 * w;
                    XTWX[1][1] += p.x2 * p.x2 * w;
                    XTWY[0] += p.x1 * p.y * w;
                    XTWY[1] += p.x2 * p.y * w;
                }
                XTWX[1][0] = XTWX[0][1];

                const det = XTWX[0][0] * XTWX[1][1] - XTWX[0][1] * XTWX[1][0];
                if (Math.abs(det) < 1e-25) {
                    return { success: false, reason: "Singular matrix: data may be collinear." };
                }

                const inv_det = 1 / det;
                q_scaled[0] = inv_det * (XTWX[1][1] * XTWY[0] - XTWX[0][1] * XTWY[1]);
                q_scaled[1] = inv_det * (-XTWX[1][0] * XTWY[0] + XTWX[0][0] * XTWY[1]);
                
                if (isRobust) {
                    const residuals = points.map(p => p.y - (q_scaled[0]*p.x1 + q_scaled[1]*p.x2));
                    const mad = d3.median(residuals.map(r => Math.abs(r - d3.median(residuals))));
                    if (mad < 1e-12) break; 
                    
                    const c = 4.685;
                    points.forEach((p, i) => {
                        const u = Math.abs(residuals[i] / (c * mad));
                        p.robustWeight = (u < 1) ? Math.pow(1 - u * u, 2) * p.weight : 0;
                    });
                }
            }
            
            let XTWX_final = [[0, 0], [0, 0]];
            for (const p of points) {
                if (p.robustWeight === 0) continue;
                const w = p.robustWeight;
                XTWX_final[0][0] += p.x1 * p.x1 * w;
                XTWX_final[0][1] += p.x1 * p.x2 * w;
                XTWX_final[1][1] += p.x2 * p.x2 * w;
            }
            XTWX_final[1][0] = XTWX_final[0][1];

            const det_final = XTWX_final[0][0] * XTWX_final[1][1] - XTWX_final[0][1] * XTWX_final[1][0];
            if (Math.abs(det_final) > 1e-25) {
                const inv_det = 1/det_final;
                const var_q1_s = inv_det * XTWX_final[1][1];
                const var_q2_s = inv_det * XTWX_final[0][0];
                esd_q_scaled[0] = var_q1_s > 0 ? Math.sqrt(var_q1_s) : NaN;
                esd_q_scaled[1] = var_q2_s > 0 ? Math.sqrt(var_q2_s) : NaN;
            }

            // Unscale parameters and errors
            const q1 = q_scaled[0] / s1;
            const q2 = q_scaled[1] / s2;
            const esd_q1 = esd_q_scaled[0] / s1;
            const esd_q2 = esd_q_scaled[1] / s2;

            const success = !isNaN(q1) && !isNaN(q2) && !isNaN(esd_q1) && !isNaN(esd_q2);
            return { q1, q2, esd_q1, esd_q2, success, reason: success ? "OK" : "Could not determine parameters." };
        }


        function analyzeAndDisplay(analyzeAll = false) {
            document.body.style.cursor = 'wait';
            setTimeout(() => {
                if (analysisResults.length === 0) {
                    document.body.style.cursor = 'default';
                    return;
                }
                
                const L = parseFloat(document.getElementById('wire-length').value) * 1e-3;
                const esd_L_ppm = parseFloat(document.getElementById('esd-wire-length-ppm').value);
                const rel_err_L_sq = Math.pow(esd_L_ppm / 1e6, 2);
                const two_b = parseFloat(document.getElementById('wire-width').value) * 1e-3;
                const esd_two_b_ppm = parseFloat(document.getElementById('esd-wire-width-ppm').value);
                const rel_err_two_b_sq = Math.pow(esd_two_b_ppm / 1e6, 2);
                const b = two_b / 2;
                const C_min = 4;
                const d_s = parseFloat(document.getElementById('thickness-substrate').value) * 1e-3;
                const fitMethod = document.getElementById('fit-method').value;
                const isRobust = fitMethod === 'robust';
                const applyPhaseCorrection = document.getElementById('phase-shift-180').checked;
                const phaseFactor = applyPhaseCorrection ? -1 : 1;
                const eulerGamma = 0.5772156;
                const MIN_ESD_V = 5E-9; 

                const performAnalysisOnDataset = (result, fitRange) => {
                    const C0 = parseFloat(document.getElementById('tcr-c0').value);
                    const C1 = parseFloat(document.getElementById('tcr-c1').value);
                    const C2 = parseFloat(document.getElementById('tcr-c2').value);

                    let alpha_tcr = 0, R_at_T_val = result.R0;
                    if (result.avg_temp > 0) {
                        const temp = result.avg_temp;
                        const dR_dT = 2 * C2 * temp + C1;
                        R_at_T_val = C2 * temp * temp + C1 * temp + C0;
                        if (R_at_T_val > 0) {
                            alpha_tcr = (1 / R_at_T_val) * dR_dT;
                        }
                    }
                    result.local_tcr = alpha_tcr;
                    const rel_err_tcr_sq = 0;

                    if (result.data && result.data.length > 0 && result.R0 > 0 && L > 0) {
                        const maxCurrent = d3.max(result.data, d => d.current);
                        result.maxPowerPerLength = (maxCurrent > 0) ? (result.R0 * maxCurrent * maxCurrent) / L : NaN;
                    } else {
                        result.maxPowerPerLength = NaN;
                    }
                    
                    result.plotData = result.data
                        .filter(d => d.isValid)
                        .map(d => ({
                            freq: d.freq,
                            i_cubed: d.i_cubed,
                            ln_2omega: d.ln_2omega,
                            v3: d.v3_in_phase * phaseFactor,
                            esdV3: Math.max(d.esdV3X, MIN_ESD_V),
                        }));

                    const dataForFit = result.plotData
                        .filter(d => d.freq >= fitRange.min && d.freq <= fitRange.max)
                        .map(d => ({ ...d, weight: d.esdV3 > 0 ? 1 / (d.esdV3 * d.esdV3) : 0 }));
                    
                    const uniqueFreqs = new Set(dataForFit.map(d => d.freq));
                    const uniqueCurrents = new Set(dataForFit.map(d => d.i_cubed));
                    if (dataForFit.length < 3 || uniqueFreqs.size < 2 || uniqueCurrents.size < 2) {
                        result.fitParams = null;
                        result.failReason = "Insufficient data variation (need at least 2 unique frequencies and currents).";
                        return;
                    }
                    
                    const fitResult = performScaledMLR(dataForFit, isRobust);

                    let k = NaN, esd_k = NaN, alpha_diff = NaN, esd_alpha_diff = NaN;

                    // Model is V = q2*(I^3) - q1*(I^3*ln(2w))
                    // So p1 = q1 and p2 = q2/q1
                    if (fitResult.success && fitResult.q1 > 0) {
                        const { q1, q2, esd_q1, esd_q2 } = fitResult;
                        
                        const p1 = q1;
                        const p2 = q2 / q1;
                        
                        const esd_p1 = esd_q1;
                        const rel_err_q1_sq = Math.pow(esd_q1/q1, 2);
                        const rel_err_q2_sq = Math.pow(esd_q2/q2, 2);
                        const esd_p2 = (q1 !== 0 && q2 !== 0) ? Math.abs(p2) * Math.sqrt(rel_err_q1_sq + rel_err_q2_sq) : NaN;

                        k = (R_at_T_val * R_at_T_val * alpha_tcr) / (4 * Math.PI * L * p1);
                        const rel_err_R_sq = 4 * Math.pow(result.esd_R0 / R_at_T_val, 2);
                        const rel_err_p1_sq = Math.pow(esd_p1 / p1, 2);
                        esd_k = Math.abs(k) * Math.sqrt(rel_err_R_sq + rel_err_tcr_sq + rel_err_L_sq + rel_err_p1_sq);

                        alpha_diff = (b * b * Math.exp(eulerGamma)) / 8 * Math.exp(p2);
                        esd_alpha_diff = Math.abs(alpha_diff) * Math.sqrt(4 * rel_err_two_b_sq + Math.pow(esd_p2, 2));

                        result.fitParams = { p1, p2 };
                        result.failReason = null;
                    } else {
                         result.fitParams = null;
                         result.failReason = fitResult.reason || "Fit failed. Check for negative thermal conductivity.";
                    }
                    
                    result.k = k; result.esd_k = esd_k;
                    result.alpha = alpha_diff * 1e6;
                    result.esd_alpha = esd_alpha_diff * 1e6;
                    
                    const alpha_m2s_for_range = result.alpha / 1e6;
                    if (alpha_m2s_for_range > 0) {
                        result.f_min_linearity = (d_s > 0) ? (C_min * C_min * alpha_m2s_for_range) / (4 * Math.PI * d_s * d_s) : NaN;
                        result.f_max_linearity = (b > 0) ? alpha_m2s_for_range / (Math.PI * b * b) : NaN;
                    } else {
                        result.f_min_linearity = NaN; result.f_max_linearity = NaN;
                    }
                };

                if (analyzeAll) {
                    analysisResults.forEach(result => {
                        performAnalysisOnDataset(result, { min: result.minFitFreq, max: result.maxFitFreq });
                    });
                } else {
                    const result = analysisResults[selectedDatasetIndex];
                    if (result) {
                        const minFitFreq = parseFloat(document.getElementById('fit-fmin').value);
                        const maxFitFreq = parseFloat(document.getElementById('fit-fmax').value);
                        result.minFitFreq = minFitFreq;
                        result.maxFitFreq = maxFitFreq;
                        performAnalysisOnDataset(result, { min: minFitFreq, max: maxFitFreq });
                    }
                }
                
                const avg_alpha_m2s = d3.mean(analysisResults.filter(d => !isNaN(d.alpha)), d => d.alpha / 1e6);
                if (avg_alpha_m2s > 0) {
                    parsedFileContent.global_f_min_linearity = (d_s > 0) ? (C_min * C_min * avg_alpha_m2s) / (4 * Math.PI * d_s * d_s) : NaN;
                    parsedFileContent.global_f_max_linearity = (b > 0) ? avg_alpha_m2s / (Math.PI * b * b) : NaN;
                }

                renderResultsUI();
                updateVisualization();
                document.body.style.cursor = 'default';
            }, 10);
        }

        function weightedPolynomialRegression2ndOrder(data) {
            const pointsToFit = data.filter(d => d.sigma > 0 && !isNaN(d.y));
            if (pointsToFit.length < 2) return { success: false, c0: 0, c1: 0, c2: 0 };
            if (pointsToFit.length < 3) {
                const fit = weightedLinearRegression(pointsToFit, 'x', 'y', 'sigma');
                return { success: true, c0: fit.intercept, c1: fit.slope, c2: 0 };
            }
            let S_w = 0, S_wx = 0, S_wy = 0, S_wx2 = 0, S_wxy = 0, S_wx3 = 0, S_wx2y = 0, S_wx4 = 0;
            for (const p of pointsToFit) {
                const w = 1 / (p.sigma * p.sigma);
                const wx = w * p.x; const wy = w * p.y; const wx2 = wx * p.x;
                S_w += w; S_wx += wx; S_wy += wy; S_wx2 += wx2;
                S_wxy += wx * p.y; S_wx3 += wx2 * p.x;
                S_wx2y += wx2 * p.y; S_wx4 += wx2 * p.x * p.x;
            }
            const A = [ [S_w, S_wx, S_wx2], [S_wx, S_wx2, S_wx3], [S_wx2, S_wx3, S_wx4] ];
            const B = [S_wy, S_wxy, S_wx2y];
            const detA = A[0][0]*(A[1][1]*A[2][2] - A[1][2]*A[2][1]) - A[0][1]*(A[1][0]*A[2][2] - A[1][2]*A[2][0]) + A[0][2]*(A[1][0]*A[2][1] - A[1][1]*A[2][0]);
            if (Math.abs(detA) < 1e-12) return { success: false, c0: 0, c1: 0, c2: 0 };
            const detA0 = B[0]*(A[1][1]*A[2][2] - A[1][2]*A[2][1]) - A[0][1]*(B[1]*A[2][2] - A[1][2]*B[2]) + A[0][2]*(B[1]*A[2][1] - A[1][1]*B[2]);
            const detA1 = A[0][0]*(B[1]*A[2][2] - A[1][2]*B[2]) - B[0]*(A[1][0]*A[2][2] - A[1][2]*A[2][0]) + A[0][2]*(A[1][0]*B[2] - B[1]*A[2][0]);
            const detA2 = A[0][0]*(A[1][1]*B[2] - B[1]*A[2][1]) - A[0][1]*(A[1][0]*B[2] - B[1]*A[2][0]) + B[0]*(A[1][0]*A[2][1] - A[1][1]*A[2][0]);
            return { success: true, c0: detA0 / detA, c1: detA1 / detA, c2: detA2 / detA };
        }

        function weightedLinearRegression(data, xKey, yKey, sigmaKey) {
            const pointsToFit = data.filter(d => d[sigmaKey] > 0 && isFinite(d[sigmaKey]) && !isNaN(d[yKey]));
            if (pointsToFit.length < 2) return { slope: NaN, intercept: NaN, esd_slope: NaN, esd_intercept: NaN };
            let sum_w = 0, sum_wx = 0, sum_wy = 0, sum_wxy = 0, sum_wxx = 0;
            for (const d of pointsToFit) {
                const w = 1 / Math.pow(d[sigmaKey], 2);
                sum_w += w; sum_wx += w * d[xKey]; sum_wy += w * d[yKey];
                sum_wxy += w * d[xKey] * d[yKey]; sum_wxx += w * d[xKey] * d[xKey];
            }
            const delta = sum_w * sum_wxx - sum_wx * sum_wx;
            if (delta === 0) return { slope: NaN, intercept: NaN, esd_slope: NaN, esd_intercept: NaN };
            const slope = (sum_w * sum_wxy - sum_wx * sum_wy) / delta;
            const intercept = (sum_wxx * sum_wy - sum_wx * sum_wxy) / delta;
            return { slope, intercept, esd_slope: Math.sqrt(sum_w / delta), esd_intercept: Math.sqrt(sum_wxx / delta) };
        }
        
        function formatTimestamp(d){return d.toISOString().slice(0,19).replace('T',' ')}
        function updateFittingUI(){if(!analysisResults[selectedDatasetIndex])return;const {minFitFreq,maxFitFreq}=analysisResults[selectedDatasetIndex];document.getElementById('fit-fmin').value=minFitFreq.toFixed(2);document.getElementById('fit-fmax').value=maxFitFreq.toFixed(2);document.getElementById('fit-fmin-slider').value=Math.log(minFitFreq);document.getElementById('fit-fmax-slider').value=Math.log(maxFitFreq);}
        function renderResultsUI(){const rrC=document.getElementById('recommended-fit-range-container'),rC=document.getElementById('results-container');rrC.innerHTML='';rC.innerHTML='';if(analysisResults.length===0)return;const f_min=parsedFileContent.global_f_min_linearity,f_max=parsedFileContent.global_f_max_linearity;if(!isNaN(f_min)&&!isNaN(f_max)){let h='<div class="results-card">';if(f_min<1e-6||f_max>1e11||f_min>=f_max){h+='<p>Recommended Fit Range: <strong>N/A</strong></p>'}else{const fd=f=>f>=1e3?`${(f/1e3).toFixed(2)} kHz`:`${f.toFixed(2)} Hz`;h+=`<p>Recommended Fit Range: <strong>${fd(Math.max(.001,f_min))} — ${fd(Math.min(1e6,f_max))}</strong></p>`}h+='</div>';rrC.innerHTML=h}const aT=document.createElement('h2');aT.textContent='Per-Dataset Analysis';rC.appendChild(aT);const cC=document.createElement('div');cC.id='dataset-controls';cC.className='control-group';const nav=document.createElement('div');nav.id='dataset-navigation';const pB=document.createElement('button');pB.id='prev-dataset-btn';pB.className='nav-btn';pB.innerHTML='▲';const nB=document.createElement('button');nB.id='next-dataset-btn';nB.className='nav-btn';nB.innerHTML='▼';nav.appendChild(pB);nav.appendChild(nB);const s=document.createElement('select');s.id='dataset-selector';analysisResults.forEach((r,i)=>{const o=document.createElement('option');o.value=i;const p=r.avg_temp>0?`${r.avg_temp.toFixed(2)} K: `:``;o.textContent=`${p}${formatTimestamp(r.timestamp)}`;if(i===selectedDatasetIndex)o.selected=true;s.appendChild(o)});pB.onclick=()=>{if(selectedDatasetIndex>0){selectedDatasetIndex--;s.value=selectedDatasetIndex;s.dispatchEvent(new Event('change'))}};nB.onclick=()=>{if(selectedDatasetIndex<analysisResults.length-1){selectedDatasetIndex++;s.value=selectedDatasetIndex;s.dispatchEvent(new Event('change'))}};s.addEventListener('change',e=>{selectedDatasetIndex=parseInt(e.target.value);isShowingRTPlot=false;updateFittingUI();displaySingleResult();updateVisualization()});const dB=document.createElement('button');dB.id='delete-dataset-btn';dB.innerHTML='&#x1F5D1;';dB.title="Delete Selected Dataset";dB.onclick=deleteSelectedDataset;cC.appendChild(nav);cC.appendChild(s);cC.appendChild(dB);rC.appendChild(cC);const caC=document.createElement('div');caC.id='single-result-card-container';rC.appendChild(caC);displaySingleResult()}
        function displaySingleResult(){const cC=document.getElementById('single-result-card-container');if(!cC||analysisResults.length===0||!analysisResults[selectedDatasetIndex]){if(cC)cC.innerHTML='';return}const r=analysisResults[selectedDatasetIndex],f_s=r.fitParams!==null&&!isNaN(r.k),f_r=r.failReason||"";let a_t='<strong>...</strong>';if(f_s)a_t=`<strong>${r.alpha.toExponential(3)} ± ${r.esd_alpha.toExponential(1)} mm²/s</strong>`;let mPT='...';if(!isNaN(r.maxPowerPerLength))mPT=`<strong>${r.maxPowerPerLength.toFixed(2)} W/m</strong>`;cC.innerHTML=`<div class="results-card" style="${!f_s?'border-left-color: #ef4444;':''}">${!f_s?`<h3>Dataset: ${formatTimestamp(r.timestamp)} (FIT FAILED)</h3><p style="color: #dc2626; font-weight: bold;">${f_r}</p>`:`<h3>Dataset: ${formatTimestamp(r.timestamp)}</h3>`}<p>Avg Temperature: <strong>${r.avg_temp>0?r.avg_temp.toFixed(2)+' K':'N/A'}</strong></p><p>Resistance (R₀): <strong>${r.R0.toFixed(2)} ± ${r.esd_R0.toExponential(1)} Ω</strong></p><p>Local TCR (α): <strong>${!isNaN(r.local_tcr)?r.local_tcr.toExponential(2):'...'} 1/K</strong></p><p>Max Power: ${mPT}</p><p>Thermal Cond. (k): <strong>${f_s?r.k.toExponential(3)+' ± '+r.esd_k.toExponential(1):'...'} W/mK</strong></p><p>Thermal Diff. (α): ${a_t}</p></div>`}
        function deleteSelectedDataset(){if(analysisResults.length===0)return;analysisResults.splice(selectedDatasetIndex,1);if(analysisResults.length===0){selectedDatasetIndex=0;document.getElementById('results-container').innerHTML='';document.getElementById('fitting-controls').classList.add('hidden');document.getElementById('save-report-btn').classList.add('hidden');clearPlot();return}selectedDatasetIndex=Math.max(0,selectedDatasetIndex-1);isShowingRTPlot=false;updateFittingUI();analyzeAndDisplay(true)}

        function updateVisualization() {
            if (isShowingRTPlot) {
                drawRTPlot();
            } else {
                draw3DPlot();
            }
        }

        const plotContainer = document.getElementById("plot-container");

        function clearPlot() {
            if (plotContainer) {
                 try { Plotly.purge(plotContainer); } catch(e) {}
                 plotContainer.innerHTML = ''; 
            }
        }

        function draw3DPlot() {
            clearPlot();
            if (!analysisResults[selectedDatasetIndex]) return;

            const result = analysisResults[selectedDatasetIndex];
            const plotData = result.plotData;
            
            if (!plotData || plotData.length === 0) {
                plotContainer.innerHTML = `<div style="text-align:center; padding-top:50px;">No valid data to plot for this dataset. ${result.failReason || ''}</div>`;
                return;
            }

            const dataInRange = plotData.filter(d => d.freq >= result.minFitFreq && d.freq <= result.maxFitFreq);
            const dataOutOfRange = plotData.filter(d => d.freq < result.minFitFreq || d.freq > result.maxFitFreq);

            const traceInRange = {
                x: dataInRange.map(d => d.ln_2omega),
                y: dataInRange.map(d => d.i_cubed),
                z: dataInRange.map(d => d.v3),
                mode: 'markers',
                type: 'scatter3d',
                name: 'Data (in fit)',
                marker: { size: 4, color: '#007bff', opacity: 0.8 }
            };

            const traceOutOfRange = {
                x: dataOutOfRange.map(d => d.ln_2omega),
                y: dataOutOfRange.map(d => d.i_cubed),
                z: dataOutOfRange.map(d => d.v3),
                mode: 'markers',
                type: 'scatter3d',
                name: 'Data (excluded)',
                marker: { size: 4, color: '#cccccc', opacity: 0.5 }
            };

            const plotTraces = [traceInRange, traceOutOfRange];
            
            if (result.fitParams && dataInRange.length > 0) {
                const p1 = result.fitParams.p1;
                const p2 = result.fitParams.p2;

                const ln_2omega_range = d3.extent(dataInRange, d => d.ln_2omega);
                const i_cubed_range = d3.extent(dataInRange, d => d.i_cubed);
                
                const surface_x = d3.range(ln_2omega_range[0], ln_2omega_range[1] + 1e-9, (ln_2omega_range[1]-ln_2omega_range[0])/20 || 1);
                const surface_y = d3.range(i_cubed_range[0], i_cubed_range[1] + 1e-9, (i_cubed_range[1]-i_cubed_range[0])/20 || 1);
                
                const surface_z = surface_y.map(y_val => {
                    return surface_x.map(x_val => p1 * y_val * (p2 - x_val));
                });
                
                const surfaceTrace = {
                    x: surface_x,
                    y: surface_y,
                    z: surface_z,
                    type: 'surface',
                    name: 'Fit',
                    opacity: 0.7,
                    colorscale: 'Blues',
                    reversescale: true,
                    showscale: false
                };
                plotTraces.push(surfaceTrace);
            }
            
            const layout = {
                title: '3D Surface Fit of V<sub>3ω</sub>',
                scene: {
                    xaxis:{title: 'ln(2ω)'},
                    yaxis:{title: 'I³ (A³)'},
                    zaxis:{title: 'V₃ In-Phase (V)'},
                },
                margin: { l: 0, r: 0, b: 0, t: 40 },
                showlegend: true,
                legend: { x: 0.8, y: 0.95 }
            };
            
            Plotly.newPlot(plotContainer, plotTraces, layout, {responsive: true});
        }


        function drawRTPlot() {
            clearPlot();

            const plotData = analysisResults.map(d => ({ x: d.avg_temp, y: d.R0, sigma: d.esd_R0 })).filter(d => d.x > 0 && !isNaN(d.y));
            if (plotData.length === 0) {
                plotContainer.innerHTML = '<div style="text-align:center; padding-top:50px;">Not enough data to display R(T) plot.</div>';
                return;
            }
            
            const d3PlotDiv = document.createElement('div');
            d3PlotDiv.classList.add('svg-container');
            plotContainer.appendChild(d3PlotDiv);
            
            const bounds = d3PlotDiv.getBoundingClientRect();
            if (bounds.width <= 0 || bounds.height <= 0) return;
            const height = bounds.height, width = bounds.width;

            const plot_margin = { top: 40, right: 40, bottom: 60, left: 80 };
            const svg = d3.select(d3PlotDiv).append("svg").attr("viewBox", `0 0 ${width} ${height}`);
            const plotArea = svg.append("g").attr("transform", `translate(${plot_margin.left},${plot_margin.top})`);
            const plotWidth = width - plot_margin.left - plot_margin.right;
            const plotHeight = height - plot_margin.top - plot_margin.bottom;
            
            let xExtent = d3.extent(plotData, d => d.x);
            let yExtent = d3.extent(plotData, d => d.y);
            
            if (plotData.length === 1) {
                xExtent = [xExtent[0] - 1, xExtent[0] + 1];
                yExtent = [yExtent[0] - yExtent[0]*0.1, yExtent[0] + yExtent[0]*0.1];
            }
            const yPadding = (yExtent[1] - yExtent[0]) * 0.1 || 1;
            
            const xScale = d3.scaleLinear().domain(xExtent).range([0, plotWidth]).nice();
            const yScale = d3.scaleLinear().domain([yExtent[0] - yPadding, yExtent[1] + yPadding]).range([plotHeight, 0]).nice();
            
            plotArea.append("g").attr("class", "axis").attr("transform", `translate(0,${plotHeight})`).call(d3.axisBottom(xScale));
            plotArea.append("g").attr("class", "axis").call(d3.axisLeft(yScale));

            svg.append("text").attr("class", "axis-label").attr("x", plot_margin.left + plotWidth / 2).attr("y", height - 10).attr('text-anchor', 'middle').text("Temperature (K)");
            svg.append("text").attr("class", "axis-label").attr("transform", "rotate(-90)").attr("y", 15).attr("x", 0 - (plot_margin.top + plotHeight / 2)).attr("text-anchor", "middle").text("Resistance (R₀) [Ω]");
            
            const capWidth = 3;
            const errorBars = plotArea.append("g").selectAll(".rt-error-bar").data(plotData).enter().append("g").attr("class", "rt-error-bar");
            errorBars.append("line").attr("x1", d => xScale(d.x)).attr("x2", d => xScale(d.x)).attr("y1", d => yScale(d.y - d.sigma)).attr("y2", d => yScale(d.y + d.sigma));
            errorBars.append("line").attr("x1", d => xScale(d.x) - capWidth).attr("x2", d => xScale(d.x) + capWidth).attr("y1", d => yScale(d.y + d.sigma)).attr("y2", d => yScale(d.y + d.sigma));
            errorBars.append("line").attr("x1", d => xScale(d.x) - capWidth).attr("x2", d => xScale(d.x) + capWidth).attr("y1", d => yScale(d.y - d.sigma)).attr("y2", d => yScale(d.y - d.sigma));
            
            plotArea.append("g").selectAll(".rt-data-point").data(plotData).enter().append("circle").attr("class", "rt-data-point").attr("cx", d => xScale(d.x)).attr("cy", d => yScale(d.y)).attr("r", 4);

            const C0 = parseFloat(document.getElementById('tcr-c0').value);
            const C1 = parseFloat(document.getElementById('tcr-c1').value);
            const C2 = parseFloat(document.getElementById('tcr-c2').value);

            if (![C0, C1, C2].some(isNaN)) {
                const curve_points = d3.range(xScale.domain()[0], xScale.domain()[1], (xScale.domain()[1] - xScale.domain()[0]) / 100);
                const line = d3.line().x(d => xScale(d)).y(d => yScale(C2 * d * d + C1 * d + C0));
                plotArea.append("path").datum(curve_points).attr("class", "rt-fit-line").attr("d", line);
            }
        }

        
        function sanitizeForPDF(text) {
            // Replaces special characters with PDF-safe equivalents
            if (typeof text !== 'string') {
                return text;
            }
            return text
                .replace(/Ω/g, 'Ohm')
                .replace(/α/g, 'alpha')
                .replace(/Δ/g, 'Delta')
                .replace(/ω/g, 'w')
                .replace(/±/g, '+/-')
                .replace(/₀/g, '0')
                .replace(/₁/g, '1')
                .replace(/₂/g, '2')
                .replace(/₃/g, '3')
                .replace(/ₛ/g, 's');
        }

function drawSummaryPlot(data, container) {
            const plotMargin = { top: 40, right: 60, bottom: 50, left: 60 };
            const width = 700 - plotMargin.left - plotMargin.right;
            const height = 400 - plotMargin.top - plotMargin.bottom;

            // Ensure the container is ready
            container.html('');
            const svg = container.append("svg")
                .attr("width", width + plotMargin.left + plotMargin.right)
                .attr("height", height + plotMargin.top + plotMargin.bottom)
                .append("g")
                .attr("transform", `translate(${plotMargin.left},${plotMargin.top})`);
            
            const validData = data.filter(d => !isNaN(d.k) && !isNaN(d.alpha) && d.fitParams);
            if (validData.length === 0) return;

            const xScale = d3.scalePoint().domain(validData.map((d, i) => i + 1)).range([0, width]).padding(0.5);
            
            const kExtent = d3.extent(validData, d => d.k);
            const alphaExtent = d3.extent(validData, d => d.alpha);

            const y1Scale = d3.scaleLinear().domain([kExtent[0] * 0.9, kExtent[1] * 1.1]).range([height, 0]).nice();
            const y2Scale = d3.scaleLinear().domain([alphaExtent[0] * 0.9, alphaExtent[1] * 1.1]).range([height, 0]).nice();

            // Axes
            svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale));
            svg.append("g").call(d3.axisLeft(y1Scale).tickFormat(d3.format(".2s"))).style("color", "#1E40AF");
            svg.append("g").attr("transform", `translate(${width},0)`).call(d3.axisRight(y2Scale).tickFormat(d3.format(".2s"))).style("color", "#B45309");

            // Labels
            svg.append("text").attr("text-anchor", "middle").attr("x", width / 2).attr("y", height + 40).text("Dataset Index");
            svg.append("text").attr("text-anchor", "middle").attr("transform", "rotate(-90)").attr("y", -plotMargin.left + 20).attr("x", -height / 2).text("Thermal Conductivity (k) [W/mK]").style("fill", "#1E40AF");
            svg.append("text").attr("text-anchor", "middle").attr("transform", "rotate(90)").attr("y", -width - plotMargin.right + 40).attr("x", height / 2).text("Thermal Diffusivity (α) [mm²/s]").style("fill", "#B45309");
            svg.append("text").attr("text-anchor", "middle").attr("x", width / 2).attr("y", -15).text("Summary of Results").style("font-size", "16px").style("font-weight", "bold");
            
            // Data points and error bars
            svg.selectAll(".dot-k").data(validData).enter().append("circle").attr("cx", (d, i) => xScale(i + 1)).attr("cy", d => y1Scale(d.k)).attr("r", 5).style("fill", "#1E40AF");
            svg.selectAll(".dot-alpha").data(validData).enter().append("circle").attr("cx", (d, i) => xScale(i + 1)).attr("cy", d => y2Scale(d.alpha)).attr("r", 5).style("fill", "#B45309");
        }

        function drawRvTPlot(data, container) {
            const plotData = data.map(d => ({ x: d.avg_temp, y: d.R0, sigma: d.esd_R0 })).filter(d => d.x > 0 && !isNaN(d.y));
            if (plotData.length < 1) return;
            
            container.html('');
            const bounds = container.node().getBoundingClientRect();
            const height = 400, width = bounds.width;
            const margin = { top: 40, right: 40, bottom: 60, left: 80 };

            const svg = container.append("svg").attr("viewBox", `0 0 ${width} ${height}`);
            const plotArea = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;
            
            const xExtent = d3.extent(plotData, d => d.x);
            const yExtent = d3.extent(plotData, d => d.y);
            const yPadding = (yExtent[1] - yExtent[0]) * 0.1 || Math.abs(yExtent[0] * 0.1) || 1;

            const xScale = d3.scaleLinear().domain([xExtent[0] - 5, xExtent[1] + 5]).range([0, plotWidth]).nice();
            const yScale = d3.scaleLinear().domain([yExtent[0] - yPadding, yExtent[1] + yPadding]).range([plotHeight, 0]).nice();

            plotArea.append("g").attr("class", "axis").attr("transform", `translate(0,${plotHeight})`).call(d3.axisBottom(xScale));
            plotArea.append("g").attr("class", "axis").call(d3.axisLeft(yScale));

            svg.append("text").attr("class", "axis-label").attr("x", margin.left + plotWidth / 2).attr("y", height - 10).attr('text-anchor', 'middle').text("Temperature (K)");
            svg.append("text").attr("class", "axis-label").attr("transform", "rotate(-90)").attr("y", 15).attr("x", 0 - (margin.top + plotHeight / 2)).attr("text-anchor", "middle").text("Resistance (R₀) [Ω]");
            svg.append("text").attr("class", "axis-label").attr("x", width/2).attr("y", margin.top-10).attr('text-anchor', 'middle').style("font-size", "18px").text("Resistance vs. Temperature");
            
            plotArea.append("g").selectAll("line").data(plotData).enter().append("line").attr("class", "rt-error-bar").attr("x1", d=>xScale(d.x)).attr("x2", d=>xScale(d.x)).attr("y1", d=>yScale(d.y-d.sigma)).attr("y2", d=>yScale(d.y+d.sigma));
            plotArea.append("g").selectAll("circle").data(plotData).enter().append("circle").attr("class", "rt-data-point").attr("cx", d => xScale(d.x)).attr("cy", d => yScale(d.y)).attr("r", 4);
            
            const C0 = parseFloat(document.getElementById('tcr-c0').value);
            const C1 = parseFloat(document.getElementById('tcr-c1').value);
            const C2 = parseFloat(document.getElementById('tcr-c2').value);

            if (![C0, C1, C2].some(isNaN)) {
                const curve_points = d3.range(xScale.domain()[0], xScale.domain()[1], (xScale.domain()[1] - xScale.domain()[0]) / 100);
                const line = d3.line().x(d => xScale(d)).y(d => yScale(C2 * d * d + C1 * d + C0));
                plotArea.append("path").datum(curve_points).attr("class", "rt-fit-line").attr("d", line);
            }
        }

        function drawConductivityVsTempPlot(data, container) {
            const plotData = data.map(d => ({ x: d.avg_temp, y: d.k, sigma: d.esd_k })).filter(d => d.x > 0 && !isNaN(d.y));
            if (plotData.length < 1) return;

            container.html('');
            const bounds = container.node().getBoundingClientRect();
            const height = 400, width = bounds.width;
            const margin = { top: 40, right: 40, bottom: 60, left: 80 };

            const svg = container.append("svg").attr("viewBox", `0 0 ${width} ${height}`);
            const plotArea = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            const xExtent = d3.extent(plotData, d => d.x);
            const yExtent = d3.extent(plotData, d => d.y);
            const yPadding = (yExtent[1] - yExtent[0]) * 0.1 || Math.abs(yExtent[0] * 0.1) || 1;

            const xScale = d3.scaleLinear().domain([xExtent[0] - 5, xExtent[1] + 5]).range([0, plotWidth]).nice();
            const yScale = d3.scaleLinear().domain([0, yExtent[1] + yPadding]).range([plotHeight, 0]).nice();
            
            plotArea.append("g").attr("class", "axis").attr("transform", `translate(0,${plotHeight})`).call(d3.axisBottom(xScale));
            plotArea.append("g").attr("class", "axis").call(d3.axisLeft(yScale));

            svg.append("text").attr("class", "axis-label").attr("x", margin.left + plotWidth / 2).attr("y", height - 10).attr('text-anchor', 'middle').text("Temperature (K)");
            svg.append("text").attr("class", "axis-label").attr("transform", "rotate(-90)").attr("y", 15).attr("x", 0 - (margin.top + plotHeight / 2)).attr("text-anchor", "middle").text("Thermal Conductivity (W/mK)");
            svg.append("text").attr("class", "axis-label").attr("x", width/2).attr("y", margin.top-10).attr('text-anchor', 'middle').style("font-size", "18px").text("Conductivity vs. Temperature");

            plotArea.append("g").selectAll("line").data(plotData).enter().append("line").attr("class", "rt-error-bar").attr("x1", d=>xScale(d.x)).attr("x2", d=>xScale(d.x)).attr("y1", d=>yScale(d.y-d.sigma)).attr("y2", d=>yScale(d.y+d.sigma));
            plotArea.append("g").selectAll("circle").data(plotData).enter().append("circle").attr("class", "rt-data-point").attr("cx", d => xScale(d.x)).attr("cy", d => yScale(d.y)).attr("r", 4);
        }

        function drawDiffusivityVsTempPlot(data, container) {
            const plotData = data.map(d => ({ x: d.avg_temp, y: d.alpha, sigma: d.esd_alpha })).filter(d => d.x > 0 && !isNaN(d.y));
            if (plotData.length < 1) return;

            container.html('');
            const bounds = container.node().getBoundingClientRect();
            const height = 400, width = bounds.width;
            const margin = { top: 40, right: 40, bottom: 60, left: 80 };

            const svg = container.append("svg").attr("viewBox", `0 0 ${width} ${height}`);
            const plotArea = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            const xExtent = d3.extent(plotData, d => d.x);
            const yExtent = d3.extent(plotData, d => d.y);
            const yPadding = (yExtent[1] - yExtent[0]) * 0.1 || Math.abs(yExtent[0] * 0.1) || 1;

            const xScale = d3.scaleLinear().domain([xExtent[0] - 5, xExtent[1] + 5]).range([0, plotWidth]).nice();
            const yScale = d3.scaleLinear().domain([0, yExtent[1] + yPadding]).range([plotHeight, 0]).nice();
            
            plotArea.append("g").attr("class", "axis").attr("transform", `translate(0,${plotHeight})`).call(d3.axisBottom(xScale));
            plotArea.append("g").attr("class", "axis").call(d3.axisLeft(yScale));
            
            svg.append("text").attr("class", "axis-label").attr("x", margin.left + plotWidth / 2).attr("y", height - 10).attr('text-anchor', 'middle').text("Temperature (K)");
            svg.append("text").attr("class", "axis-label").attr("transform", "rotate(-90)").attr("y", 15).attr("x", 0 - (margin.top + plotHeight / 2)).attr("text-anchor", "middle").text("Thermal Diffusivity (mm²/s)");
            svg.append("text").attr("class", "axis-label").attr("x", width/2).attr("y", margin.top-10).attr('text-anchor', 'middle').style("font-size", "18px").text("Diffusivity vs. Temperature");
            
            plotArea.append("g").selectAll("line").data(plotData).enter().append("line").attr("class", "rt-error-bar").attr("x1", d=>xScale(d.x)).attr("x2", d=>xScale(d.x)).attr("y1", d=>yScale(d.y-d.sigma)).attr("y2", d=>yScale(d.y+d.sigma));
            plotArea.append("g").selectAll("circle").data(plotData).enter().append("circle").attr("class", "rt-data-point").attr("cx", d => xScale(d.x)).attr("cy", d => yScale(d.y)).attr("r", 4);
        }

async function exportPDFReport() {
            // --- Make cursor busy ---
            document.body.style.cursor = 'wait';

            const btn = document.getElementById('save-report-btn');
            btn.textContent = 'Generating...';
            btn.disabled = true;

            const originalSelectedDatasetIndex = selectedDatasetIndex;
            const tempPlotContainer = d3.select("#pdf-plot-temp-container");

            try {
                const pdf = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 15;
                let yPos = margin;

                pdf.setFontSize(20).text("3-Omega Analysis Report", pageWidth / 2, yPos, { align: 'center' });
                yPos += 10;

                let sampleName = 'N/A';
                const header = parsedFileContent.jsonHeader;
                if (header) {
                    sampleName = header.exp?.Sample || header.exp?.sample || header.Sample || header['sample name'] || 'N/A';
                }

                const startTime = analysisResults.length > 0 ? analysisResults[0].timestamp : null;
                const endTime = analysisResults.length > 0 ? analysisResults[analysisResults.length - 1].timestamp : null;
                const measurementDateString = (startTime && endTime) 
                    ? `${formatTimestamp(startTime)} to ${formatTimestamp(endTime)}`
                    : 'Not available';

                pdf.setFontSize(12).text(`Sample: ${sampleName}`, pageWidth / 2, yPos, { align: 'center' });
                yPos += 7;
                pdf.setFontSize(12).text(`Data measured: ${measurementDateString}`, pageWidth / 2, yPos, { align: 'center' });
                yPos += 7;

                pdf.setFontSize(10).text(`Report generated: ${new Date().toLocaleString()}`, pageWidth / 2, yPos, { align: 'center' });
                yPos += 12;

                pdf.setFontSize(10).text("Data File Header Information", margin, yPos);
                yPos += 6;
                pdf.setLineWidth(0.2).line(margin, yPos, pageWidth - margin, yPos);
                yPos += 8;
                pdf.setFontSize(8).setFont('courier');
                if (parsedFileContent.jsonHeader) {
                    const headerString = JSON.stringify(parsedFileContent.jsonHeader, null, 2);
                    const headerLines = pdf.splitTextToSize(headerString, pageWidth - 2 * margin);
                    for (const line of headerLines) {
                        if (yPos > pageHeight - margin) { pdf.addPage(); yPos = margin; }
                        pdf.text(line, margin, yPos);
                        yPos += 4;
                    }
                } else {
                    pdf.text("No JSON header found.", margin, yPos);
                }
                pdf.setFont('helvetica').setFontSize(10);
                
                pdf.addPage();
                yPos = margin;
                pdf.setFontSize(16).text("Summary Table", pageWidth / 2, yPos, { align: 'center' });
                yPos += 12;
                pdf.setFontSize(9).setFont('courier', 'bold');

                const col_positions = [margin, 50, 95, 145];
                pdf.text("Temp (K)", col_positions[0], yPos);
                pdf.text("R0 (Ohm)", col_positions[1], yPos);
                pdf.text("k (W/mK)", col_positions[2], yPos);
                pdf.text("alpha (mm2/s)", col_positions[3], yPos);
                yPos += 2;
                pdf.setLineWidth(0.3).line(margin, yPos, pageWidth - margin, yPos);
                yPos += 5;
                pdf.setFont('courier', 'normal');

                analysisResults.forEach(res => {
                    if (yPos > pageHeight - margin - 10) { pdf.addPage(); yPos = margin; }
                    const temp_str = res.avg_temp > 0 ? res.avg_temp.toFixed(2) : 'N/A';
                    const R0_str = `${res.R0.toFixed(3)} +/- ${res.esd_R0.toExponential(1)}`;
                    const k_str = !isNaN(res.k) ? `${res.k.toExponential(2)} +/- ${res.esd_k.toExponential(1)}` : 'N/A';
                    const alpha_str = !isNaN(res.alpha) ? `${res.alpha.toExponential(2)} +/- ${res.esd_alpha.toExponential(1)}` : 'N/A';
                    
                    pdf.text(temp_str, col_positions[0], yPos);
                    pdf.text(R0_str, col_positions[1], yPos);
                    pdf.text(k_str, col_positions[2], yPos);
                    pdf.text(alpha_str, col_positions[3], yPos);
                    yPos += 6;
                });
                
                pdf.setFont('helvetica', 'normal');

                for (let i = 0; i < analysisResults.length; i++) {
                    pdf.addPage();
                    yPos = margin;
                    const result = analysisResults[i];

                    pdf.setFontSize(16).text(`Dataset Analysis: ${formatTimestamp(result.timestamp)}`, pageWidth / 2, yPos, { align: 'center' });
                    yPos += 12;

                    pdf.setFontSize(12).text("Parameters & Results", margin, yPos);
                    yPos += 6;
                    pdf.setLineWidth(0.2).line(margin, yPos, pageWidth - margin, yPos);
                    yPos += 8;
                    pdf.setFontSize(9);

                    const col1_x = margin;
                    const col2_x = margin + (pageWidth - 2 * margin) / 2;
                    let yPos_col1 = yPos, yPos_col2 = yPos;
                    const L_val_mm = parseFloat(document.getElementById('wire-length').value);
                    const L_ppm = parseFloat(document.getElementById('esd-wire-length-ppm').value);
                    const two_b_val_mm = parseFloat(document.getElementById('wire-width').value);
                    const two_b_ppm = parseFloat(document.getElementById('esd-wire-width-ppm').value);
                    const C0 = parseFloat(document.getElementById('tcr-c0').value);
                    const C1 = parseFloat(document.getElementById('tcr-c1').value);
                    const C2 = parseFloat(document.getElementById('tcr-c2').value);

                    pdf.text(sanitizeForPDF(`Voltage Probe Distance (L): ${L_val_mm.toFixed(3)} ± ${(L_val_mm * L_ppm / 1e6).toExponential(1)} mm`), col1_x, yPos_col1); yPos_col1 += 6;
                    pdf.text(sanitizeForPDF(`Wire Width (2b): ${two_b_val_mm.toFixed(3)} ± ${(two_b_val_mm * two_b_ppm / 1e6).toExponential(1)} mm`), col1_x, yPos_col1); yPos_col1 += 6;
                    pdf.text(sanitizeForPDF(`Substrate Thickness (dₛ): ${document.getElementById('thickness-substrate').value} mm`), col1_x, yPos_col1); yPos_col1 += 6;
                    pdf.text(`Fit Method: ${document.getElementById('fit-method').value}`, col1_x, yPos_col1); yPos_col1 += 6;
                    pdf.text(`Fitting Range: ${result.minFitFreq.toFixed(2)} Hz to ${result.maxFitFreq.toFixed(2)} Hz`, col1_x, yPos_col1); yPos_col1 += 6;
                    yPos_col1 += 4;
                    pdf.text(sanitizeForPDF(`R(T) Coeffs: C₀=${C0.toExponential(2)}, C₁=${C1.toExponential(2)}, C₂=${C2.toExponential(2)}`), col1_x, yPos_col1); yPos_col1 += 6;

                    pdf.text(sanitizeForPDF(`Avg Temperature: ${result.avg_temp > 0 ? result.avg_temp.toFixed(2) + ' K' : 'N/A'}`), col2_x, yPos_col2); yPos_col2 += 6;
                    pdf.text(sanitizeForPDF(`Resistance (R₀): ${result.R0.toFixed(2)} ± ${result.esd_R0.toExponential(1)} Ω`), col2_x, yPos_col2); yPos_col2 += 6;
                    pdf.text(sanitizeForPDF(`Local TCR (α): ${!isNaN(result.local_tcr) ? result.local_tcr.toExponential(2) : 'N/A'} 1/K`), col2_x, yPos_col2); yPos_col2 += 6;
                    const max_power_text_pdf = !isNaN(result.maxPowerPerLength) ? `${result.maxPowerPerLength.toFixed(2)} W/m` : 'N/A';
                    pdf.text(sanitizeForPDF(`Max Power: ${max_power_text_pdf}`), col2_x, yPos_col2); yPos_col2 += 6;
                    const k_text_pdf = !isNaN(result.k) ? `${result.k.toExponential(3)} ± ${result.esd_k.toExponential(1)} W/mK` : 'N/A';
                    pdf.text(sanitizeForPDF(`Thermal Conductivity (k): ${k_text_pdf}`), col2_x, yPos_col2); yPos_col2 += 6;
                    const alpha_text_pdf = !isNaN(result.alpha) ? `${result.alpha.toExponential(3)} ± ${result.esd_alpha.toExponential(1)} mm²/s` : 'N/A';
                    pdf.text(sanitizeForPDF(`Thermal Diffusivity (α): ${alpha_text_pdf}`), col2_x, yPos_col2); yPos_col2 += 6;
                    
                    if (!isNaN(result.f_min_linearity) && !isNaN(result.f_max_linearity)) {
                        const f_max_formatted = result.f_max_linearity > 1000 ? `${(result.f_max_linearity/1000).toFixed(1)} kHz` : `${result.f_max_linearity.toFixed(1)} Hz`;
                        pdf.text(sanitizeForPDF(`Rec. Fit Range: ${result.f_min_linearity.toFixed(1)} Hz - ${f_max_formatted}`), col2_x, yPos_col2); yPos_col2 += 6;
                    }

                    yPos = Math.max(yPos_col1, yPos_col2) + 5;
                    selectedDatasetIndex = i;
                    
                    isShowingRTPlot = false;
                    updateVisualization();
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    const plotDiv = document.getElementById('plot-container');
                    const imgData = await Plotly.toImage(plotDiv, {
                        format: 'png', 
                        width: 1000,
                        height: 750
                    });

                    const availableHeight = pageHeight - yPos - margin;
                    let imgWidth = pageWidth - 2 * margin;
                    let imgHeight = (750 * imgWidth) / 1000; 

                    if (imgHeight > availableHeight) {
                        imgHeight = availableHeight;
                        imgWidth = (1000 * imgHeight) / 750;
                    }
                    pdf.addImage(imgData, 'PNG', (pageWidth - imgWidth) / 2, yPos, imgWidth, imgHeight);
                }

                if (analysisResults.length > 0) {
                    pdf.addPage();
                    yPos = margin;
                    pdf.setFontSize(16).text("Analysis Summary", pageWidth / 2, yPos, { align: 'center' });
                    yPos += 10;
                    
                    tempPlotContainer.html(''); 
                    drawSummaryPlot(analysisResults, tempPlotContainer);
                    await new Promise(resolve => setTimeout(resolve, 300));
                    let canvas1 = await html2canvas(tempPlotContainer.node(), { scale: 2, backgroundColor: '#ffffff' });
                    let imgWidth1 = pageWidth - 2 * margin;
                    if (canvas1.height > 20) {
                        let imgHeight1 = (canvas1.height * imgWidth1) / canvas1.width;
                        pdf.addImage(canvas1.toDataURL('image/png'), 'PNG', margin, yPos, imgWidth1, imgHeight1);
                        yPos += imgHeight1 + 10;
                    }

                    const temps = analysisResults.map(d => d.avg_temp).filter(t => t > 0);
                    if (new Set(temps).size > 1) {
                        
                        tempPlotContainer.html('');
                        drawRvTPlot(analysisResults, tempPlotContainer);
                        await new Promise(resolve => setTimeout(resolve, 300));
                        const canvas2 = await html2canvas(tempPlotContainer.node(), { scale: 2, backgroundColor: '#ffffff' });
                        if (canvas2.height > 20) {
                            const imgHeight2 = (canvas2.height * imgWidth1) / canvas2.width;
                            if (yPos + imgHeight2 > pageHeight - margin) { pdf.addPage(); yPos = margin; }
                            pdf.addImage(canvas2.toDataURL('image/png'), 'PNG', margin, yPos, imgWidth1, imgHeight2);
                            yPos += imgHeight2 + 10;
                        }
                        
                        tempPlotContainer.html('');
                        drawConductivityVsTempPlot(analysisResults, tempPlotContainer);
                        await new Promise(resolve => setTimeout(resolve, 300));
                        let canvas3 = await html2canvas(tempPlotContainer.node(), { scale: 2, backgroundColor: '#ffffff' });
                        if (canvas3.height > 20) {
                            let imgHeight3 = (canvas3.height * imgWidth1) / canvas3.width;
                            if (yPos + imgHeight3 > pageHeight - margin) { pdf.addPage(); yPos = margin; }
                            pdf.addImage(canvas3.toDataURL('image/png'), 'PNG', margin, yPos, imgWidth1, imgHeight3);
                            yPos += imgHeight3 + 10;
                        }

                        tempPlotContainer.html('');
                        drawDiffusivityVsTempPlot(analysisResults, tempPlotContainer);
                        await new Promise(resolve => setTimeout(resolve, 300));
                        let canvas4 = await html2canvas(tempPlotContainer.node(), { scale: 2, backgroundColor: '#ffffff' });
                        if (canvas4.height > 20) {
                            let imgHeight4 = (canvas4.height * imgWidth1) / canvas4.width;
                             if (yPos + imgHeight4 > pageHeight - margin) { pdf.addPage(); yPos = margin; }
                            pdf.addImage(canvas4.toDataURL('image/png'), 'PNG', margin, yPos, imgWidth1, imgHeight4);
                        }
                    }
                }
                pdf.save(`3omega_3D-Fit-report_${new Date().toISOString().replace(/[:.]/g, '-')}.pdf`);
            } catch (error) {
                console.error("Error generating PDF:", error);
                showError("An error occurred while generating the PDF. See browser console.");
            } finally {
                // --- Reset cursor to normal ---
                document.body.style.cursor = 'default';
                selectedDatasetIndex = originalSelectedDatasetIndex;
                if (document.getElementById('dataset-selector')) document.getElementById('dataset-selector').value = selectedDatasetIndex;
                isShowingRTPlot = false;
                updateVisualization();
                tempPlotContainer.html('');
                btn.textContent = 'Save Report';
                btn.disabled = false;
            }
        }

        const resizer = document.getElementById('drag-handle');
        const leftPanel = document.getElementById('controls-panel');
        let isResizing = false;
        resizer.addEventListener('mousedown', e => { e.preventDefault(); isResizing = true; document.body.style.cursor = 'col-resize'; document.body.style.userSelect = 'none'; window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mouseup', stopResize); });
        function handleMouseMove(e) { if (!isResizing) return; const newLeftWidth = e.clientX - resizer.parentElement.getBoundingClientRect().left; if (newLeftWidth > 350 && newLeftWidth < resizer.parentElement.clientWidth - 400) { leftPanel.style.width = `${newLeftWidth}px`; try{Plotly.relayout(plotContainer, {autosize: true});}catch(e){} } }
        function stopResize() { isResizing = false; document.body.style.cursor = 'default'; document.body.style.userSelect = 'auto'; window.removeEventListener('mousemove', handleMouseMove); window.removeEventListener('mouseup', stopResize); }
        new ResizeObserver(() => { if (analysisResults.length > 0) { try{Plotly.relayout(plotContainer, {autosize: true});}catch(e){} } }).observe(plotContainer);
    });
</script>
</body>
</html>